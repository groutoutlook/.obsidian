/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/ev-emitter/ev-emitter.js
var require_ev_emitter = __commonJS({
  "node_modules/ev-emitter/ev-emitter.js"(exports, module2) {
    (function(global2, factory) {
      if (typeof define == "function" && define.amd) {
        define(factory);
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory();
      } else {
        global2.EvEmitter = factory();
      }
    })(typeof window != "undefined" ? window : exports, function() {
      "use strict";
      function EvEmitter() {
      }
      var proto = EvEmitter.prototype;
      proto.on = function(eventName, listener) {
        if (!eventName || !listener) {
          return;
        }
        var events = this._events = this._events || {};
        var listeners = events[eventName] = events[eventName] || [];
        if (listeners.indexOf(listener) == -1) {
          listeners.push(listener);
        }
        return this;
      };
      proto.once = function(eventName, listener) {
        if (!eventName || !listener) {
          return;
        }
        this.on(eventName, listener);
        var onceEvents = this._onceEvents = this._onceEvents || {};
        var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
        onceListeners[listener] = true;
        return this;
      };
      proto.off = function(eventName, listener) {
        var listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length) {
          return;
        }
        var index = listeners.indexOf(listener);
        if (index != -1) {
          listeners.splice(index, 1);
        }
        return this;
      };
      proto.emitEvent = function(eventName, args) {
        var listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length) {
          return;
        }
        listeners = listeners.slice(0);
        args = args || [];
        var onceListeners = this._onceEvents && this._onceEvents[eventName];
        for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];
          var isOnce = onceListeners && onceListeners[listener];
          if (isOnce) {
            this.off(eventName, listener);
            delete onceListeners[listener];
          }
          listener.apply(this, args);
        }
        return this;
      };
      proto.allOff = function() {
        delete this._events;
        delete this._onceEvents;
      };
      return EvEmitter;
    });
  }
});

// node_modules/get-size/get-size.js
var require_get_size = __commonJS({
  "node_modules/get-size/get-size.js"(exports, module2) {
    (function(window2, factory) {
      if (typeof define == "function" && define.amd) {
        define(factory);
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory();
      } else {
        window2.getSize = factory();
      }
    })(window, function factory() {
      "use strict";
      function getStyleSize(value) {
        var num = parseFloat(value);
        var isValid = value.indexOf("%") == -1 && !isNaN(num);
        return isValid && num;
      }
      function noop2() {
      }
      var logError = typeof console == "undefined" ? noop2 : function(message) {
        console.error(message);
      };
      var measurements = [
        "paddingLeft",
        "paddingRight",
        "paddingTop",
        "paddingBottom",
        "marginLeft",
        "marginRight",
        "marginTop",
        "marginBottom",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth",
        "borderBottomWidth"
      ];
      var measurementsLength = measurements.length;
      function getZeroSize() {
        var size = {
          width: 0,
          height: 0,
          innerWidth: 0,
          innerHeight: 0,
          outerWidth: 0,
          outerHeight: 0
        };
        for (var i = 0; i < measurementsLength; i++) {
          var measurement = measurements[i];
          size[measurement] = 0;
        }
        return size;
      }
      function getStyle(elem) {
        var style = getComputedStyle(elem);
        if (!style) {
          logError("Style returned " + style + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1");
        }
        return style;
      }
      var isSetup = false;
      var isBoxSizeOuter;
      function setup() {
        if (isSetup) {
          return;
        }
        isSetup = true;
        var div = document.createElement("div");
        div.style.width = "200px";
        div.style.padding = "1px 2px 3px 4px";
        div.style.borderStyle = "solid";
        div.style.borderWidth = "1px 2px 3px 4px";
        div.style.boxSizing = "border-box";
        var body = document.body || document.documentElement;
        body.appendChild(div);
        var style = getStyle(div);
        isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
        getSize.isBoxSizeOuter = isBoxSizeOuter;
        body.removeChild(div);
      }
      function getSize(elem) {
        setup();
        if (typeof elem == "string") {
          elem = document.querySelector(elem);
        }
        if (!elem || typeof elem != "object" || !elem.nodeType) {
          return;
        }
        var style = getStyle(elem);
        if (style.display == "none") {
          return getZeroSize();
        }
        var size = {};
        size.width = elem.offsetWidth;
        size.height = elem.offsetHeight;
        var isBorderBox = size.isBorderBox = style.boxSizing == "border-box";
        for (var i = 0; i < measurementsLength; i++) {
          var measurement = measurements[i];
          var value = style[measurement];
          var num = parseFloat(value);
          size[measurement] = !isNaN(num) ? num : 0;
        }
        var paddingWidth = size.paddingLeft + size.paddingRight;
        var paddingHeight = size.paddingTop + size.paddingBottom;
        var marginWidth = size.marginLeft + size.marginRight;
        var marginHeight = size.marginTop + size.marginBottom;
        var borderWidth = size.borderLeftWidth + size.borderRightWidth;
        var borderHeight = size.borderTopWidth + size.borderBottomWidth;
        var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
        var styleWidth = getStyleSize(style.width);
        if (styleWidth !== false) {
          size.width = styleWidth + // add padding and border unless it's already including it
          (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
        }
        var styleHeight = getStyleSize(style.height);
        if (styleHeight !== false) {
          size.height = styleHeight + // add padding and border unless it's already including it
          (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
        }
        size.innerWidth = size.width - (paddingWidth + borderWidth);
        size.innerHeight = size.height - (paddingHeight + borderHeight);
        size.outerWidth = size.width + marginWidth;
        size.outerHeight = size.height + marginHeight;
        return size;
      }
      return getSize;
    });
  }
});

// node_modules/desandro-matches-selector/matches-selector.js
var require_matches_selector = __commonJS({
  "node_modules/desandro-matches-selector/matches-selector.js"(exports, module2) {
    (function(window2, factory) {
      "use strict";
      if (typeof define == "function" && define.amd) {
        define(factory);
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory();
      } else {
        window2.matchesSelector = factory();
      }
    })(window, function factory() {
      "use strict";
      var matchesMethod = function() {
        var ElemProto = window.Element.prototype;
        if (ElemProto.matches) {
          return "matches";
        }
        if (ElemProto.matchesSelector) {
          return "matchesSelector";
        }
        var prefixes = ["webkit", "moz", "ms", "o"];
        for (var i = 0; i < prefixes.length; i++) {
          var prefix = prefixes[i];
          var method = prefix + "MatchesSelector";
          if (ElemProto[method]) {
            return method;
          }
        }
      }();
      return function matchesSelector(elem, selector) {
        return elem[matchesMethod](selector);
      };
    });
  }
});

// node_modules/fizzy-ui-utils/utils.js
var require_utils = __commonJS({
  "node_modules/fizzy-ui-utils/utils.js"(exports, module2) {
    (function(window2, factory) {
      if (typeof define == "function" && define.amd) {
        define([
          "desandro-matches-selector/matches-selector"
        ], function(matchesSelector) {
          return factory(window2, matchesSelector);
        });
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory(
          window2,
          require_matches_selector()
        );
      } else {
        window2.fizzyUIUtils = factory(
          window2,
          window2.matchesSelector
        );
      }
    })(window, function factory(window2, matchesSelector) {
      "use strict";
      var utils = {};
      utils.extend = function(a, b) {
        for (var prop in b) {
          a[prop] = b[prop];
        }
        return a;
      };
      utils.modulo = function(num, div) {
        return (num % div + div) % div;
      };
      var arraySlice = Array.prototype.slice;
      utils.makeArray = function(obj) {
        if (Array.isArray(obj)) {
          return obj;
        }
        if (obj === null || obj === void 0) {
          return [];
        }
        var isArrayLike = typeof obj == "object" && typeof obj.length == "number";
        if (isArrayLike) {
          return arraySlice.call(obj);
        }
        return [obj];
      };
      utils.removeFrom = function(ary, obj) {
        var index = ary.indexOf(obj);
        if (index != -1) {
          ary.splice(index, 1);
        }
      };
      utils.getParent = function(elem, selector) {
        while (elem.parentNode && elem != document.body) {
          elem = elem.parentNode;
          if (matchesSelector(elem, selector)) {
            return elem;
          }
        }
      };
      utils.getQueryElement = function(elem) {
        if (typeof elem == "string") {
          return document.querySelector(elem);
        }
        return elem;
      };
      utils.handleEvent = function(event) {
        var method = "on" + event.type;
        if (this[method]) {
          this[method](event);
        }
      };
      utils.filterFindElements = function(elems, selector) {
        elems = utils.makeArray(elems);
        var ffElems = [];
        elems.forEach(function(elem) {
          if (!(elem instanceof HTMLElement)) {
            return;
          }
          if (!selector) {
            ffElems.push(elem);
            return;
          }
          if (matchesSelector(elem, selector)) {
            ffElems.push(elem);
          }
          var childElems = elem.querySelectorAll(selector);
          for (var i = 0; i < childElems.length; i++) {
            ffElems.push(childElems[i]);
          }
        });
        return ffElems;
      };
      utils.debounceMethod = function(_class, methodName, threshold) {
        threshold = threshold || 100;
        var method = _class.prototype[methodName];
        var timeoutName = methodName + "Timeout";
        _class.prototype[methodName] = function() {
          var timeout = this[timeoutName];
          clearTimeout(timeout);
          var args = arguments;
          var _this = this;
          this[timeoutName] = setTimeout(function() {
            method.apply(_this, args);
            delete _this[timeoutName];
          }, threshold);
        };
      };
      utils.docReady = function(callback) {
        var readyState = document.readyState;
        if (readyState == "complete" || readyState == "interactive") {
          setTimeout(callback);
        } else {
          document.addEventListener("DOMContentLoaded", callback);
        }
      };
      utils.toDashed = function(str) {
        return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
          return $1 + "-" + $2;
        }).toLowerCase();
      };
      var console2 = window2.console;
      utils.htmlInit = function(WidgetClass, namespace) {
        utils.docReady(function() {
          var dashedNamespace = utils.toDashed(namespace);
          var dataAttr = "data-" + dashedNamespace;
          var dataAttrElems = document.querySelectorAll("[" + dataAttr + "]");
          var jsDashElems = document.querySelectorAll(".js-" + dashedNamespace);
          var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
          var dataOptionsAttr = dataAttr + "-options";
          var jQuery = window2.jQuery;
          elems.forEach(function(elem) {
            var attr2 = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
            var options;
            try {
              options = attr2 && JSON.parse(attr2);
            } catch (error) {
              if (console2) {
                console2.error("Error parsing " + dataAttr + " on " + elem.className + ": " + error);
              }
              return;
            }
            var instance10 = new WidgetClass(elem, options);
            if (jQuery) {
              jQuery.data(elem, namespace, instance10);
            }
          });
        });
      };
      return utils;
    });
  }
});

// node_modules/outlayer/item.js
var require_item = __commonJS({
  "node_modules/outlayer/item.js"(exports, module2) {
    (function(window2, factory) {
      if (typeof define == "function" && define.amd) {
        define(
          [
            "ev-emitter/ev-emitter",
            "get-size/get-size"
          ],
          factory
        );
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory(
          require_ev_emitter(),
          require_get_size()
        );
      } else {
        window2.Outlayer = {};
        window2.Outlayer.Item = factory(
          window2.EvEmitter,
          window2.getSize
        );
      }
    })(window, function factory(EvEmitter, getSize) {
      "use strict";
      function isEmptyObj(obj) {
        for (var prop in obj) {
          return false;
        }
        prop = null;
        return true;
      }
      var docElemStyle = document.documentElement.style;
      var transitionProperty = typeof docElemStyle.transition == "string" ? "transition" : "WebkitTransition";
      var transformProperty = typeof docElemStyle.transform == "string" ? "transform" : "WebkitTransform";
      var transitionEndEvent = {
        WebkitTransition: "webkitTransitionEnd",
        transition: "transitionend"
      }[transitionProperty];
      var vendorProperties = {
        transform: transformProperty,
        transition: transitionProperty,
        transitionDuration: transitionProperty + "Duration",
        transitionProperty: transitionProperty + "Property",
        transitionDelay: transitionProperty + "Delay"
      };
      function Item(element2, layout) {
        if (!element2) {
          return;
        }
        this.element = element2;
        this.layout = layout;
        this.position = {
          x: 0,
          y: 0
        };
        this._create();
      }
      var proto = Item.prototype = Object.create(EvEmitter.prototype);
      proto.constructor = Item;
      proto._create = function() {
        this._transn = {
          ingProperties: {},
          clean: {},
          onEnd: {}
        };
        this.css({
          position: "absolute"
        });
      };
      proto.handleEvent = function(event) {
        var method = "on" + event.type;
        if (this[method]) {
          this[method](event);
        }
      };
      proto.getSize = function() {
        this.size = getSize(this.element);
      };
      proto.css = function(style) {
        var elemStyle = this.element.style;
        for (var prop in style) {
          var supportedProp = vendorProperties[prop] || prop;
          elemStyle[supportedProp] = style[prop];
        }
      };
      proto.getPosition = function() {
        var style = getComputedStyle(this.element);
        var isOriginLeft = this.layout._getOption("originLeft");
        var isOriginTop = this.layout._getOption("originTop");
        var xValue = style[isOriginLeft ? "left" : "right"];
        var yValue = style[isOriginTop ? "top" : "bottom"];
        var x = parseFloat(xValue);
        var y = parseFloat(yValue);
        var layoutSize = this.layout.size;
        if (xValue.indexOf("%") != -1) {
          x = x / 100 * layoutSize.width;
        }
        if (yValue.indexOf("%") != -1) {
          y = y / 100 * layoutSize.height;
        }
        x = isNaN(x) ? 0 : x;
        y = isNaN(y) ? 0 : y;
        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
        this.position.x = x;
        this.position.y = y;
      };
      proto.layoutPosition = function() {
        var layoutSize = this.layout.size;
        var style = {};
        var isOriginLeft = this.layout._getOption("originLeft");
        var isOriginTop = this.layout._getOption("originTop");
        var xPadding = isOriginLeft ? "paddingLeft" : "paddingRight";
        var xProperty = isOriginLeft ? "left" : "right";
        var xResetProperty = isOriginLeft ? "right" : "left";
        var x = this.position.x + layoutSize[xPadding];
        style[xProperty] = this.getXValue(x);
        style[xResetProperty] = "";
        var yPadding = isOriginTop ? "paddingTop" : "paddingBottom";
        var yProperty = isOriginTop ? "top" : "bottom";
        var yResetProperty = isOriginTop ? "bottom" : "top";
        var y = this.position.y + layoutSize[yPadding];
        style[yProperty] = this.getYValue(y);
        style[yResetProperty] = "";
        this.css(style);
        this.emitEvent("layout", [this]);
      };
      proto.getXValue = function(x) {
        var isHorizontal = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + "%" : x + "px";
      };
      proto.getYValue = function(y) {
        var isHorizontal = this.layout._getOption("horizontal");
        return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + "%" : y + "px";
      };
      proto._transitionTo = function(x, y) {
        this.getPosition();
        var curX = this.position.x;
        var curY = this.position.y;
        var didNotMove = x == this.position.x && y == this.position.y;
        this.setPosition(x, y);
        if (didNotMove && !this.isTransitioning) {
          this.layoutPosition();
          return;
        }
        var transX = x - curX;
        var transY = y - curY;
        var transitionStyle = {};
        transitionStyle.transform = this.getTranslate(transX, transY);
        this.transition({
          to: transitionStyle,
          onTransitionEnd: {
            transform: this.layoutPosition
          },
          isCleaning: true
        });
      };
      proto.getTranslate = function(x, y) {
        var isOriginLeft = this.layout._getOption("originLeft");
        var isOriginTop = this.layout._getOption("originTop");
        x = isOriginLeft ? x : -x;
        y = isOriginTop ? y : -y;
        return "translate3d(" + x + "px, " + y + "px, 0)";
      };
      proto.goTo = function(x, y) {
        this.setPosition(x, y);
        this.layoutPosition();
      };
      proto.moveTo = proto._transitionTo;
      proto.setPosition = function(x, y) {
        this.position.x = parseFloat(x);
        this.position.y = parseFloat(y);
      };
      proto._nonTransition = function(args) {
        this.css(args.to);
        if (args.isCleaning) {
          this._removeStyles(args.to);
        }
        for (var prop in args.onTransitionEnd) {
          args.onTransitionEnd[prop].call(this);
        }
      };
      proto.transition = function(args) {
        if (!parseFloat(this.layout.options.transitionDuration)) {
          this._nonTransition(args);
          return;
        }
        var _transition = this._transn;
        for (var prop in args.onTransitionEnd) {
          _transition.onEnd[prop] = args.onTransitionEnd[prop];
        }
        for (prop in args.to) {
          _transition.ingProperties[prop] = true;
          if (args.isCleaning) {
            _transition.clean[prop] = true;
          }
        }
        if (args.from) {
          this.css(args.from);
          var h = this.element.offsetHeight;
          h = null;
        }
        this.enableTransition(args.to);
        this.css(args.to);
        this.isTransitioning = true;
      };
      function toDashedAll(str) {
        return str.replace(/([A-Z])/g, function($1) {
          return "-" + $1.toLowerCase();
        });
      }
      var transitionProps = "opacity," + toDashedAll(transformProperty);
      proto.enableTransition = function() {
        if (this.isTransitioning) {
          return;
        }
        var duration = this.layout.options.transitionDuration;
        duration = typeof duration == "number" ? duration + "ms" : duration;
        this.css({
          transitionProperty: transitionProps,
          transitionDuration: duration,
          transitionDelay: this.staggerDelay || 0
        });
        this.element.addEventListener(transitionEndEvent, this, false);
      };
      proto.onwebkitTransitionEnd = function(event) {
        this.ontransitionend(event);
      };
      proto.onotransitionend = function(event) {
        this.ontransitionend(event);
      };
      var dashedVendorProperties = {
        "-webkit-transform": "transform"
      };
      proto.ontransitionend = function(event) {
        if (event.target !== this.element) {
          return;
        }
        var _transition = this._transn;
        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;
        delete _transition.ingProperties[propertyName];
        if (isEmptyObj(_transition.ingProperties)) {
          this.disableTransition();
        }
        if (propertyName in _transition.clean) {
          this.element.style[event.propertyName] = "";
          delete _transition.clean[propertyName];
        }
        if (propertyName in _transition.onEnd) {
          var onTransitionEnd = _transition.onEnd[propertyName];
          onTransitionEnd.call(this);
          delete _transition.onEnd[propertyName];
        }
        this.emitEvent("transitionEnd", [this]);
      };
      proto.disableTransition = function() {
        this.removeTransitionStyles();
        this.element.removeEventListener(transitionEndEvent, this, false);
        this.isTransitioning = false;
      };
      proto._removeStyles = function(style) {
        var cleanStyle = {};
        for (var prop in style) {
          cleanStyle[prop] = "";
        }
        this.css(cleanStyle);
      };
      var cleanTransitionStyle = {
        transitionProperty: "",
        transitionDuration: "",
        transitionDelay: ""
      };
      proto.removeTransitionStyles = function() {
        this.css(cleanTransitionStyle);
      };
      proto.stagger = function(delay) {
        delay = isNaN(delay) ? 0 : delay;
        this.staggerDelay = delay + "ms";
      };
      proto.removeElem = function() {
        this.element.parentNode.removeChild(this.element);
        this.css({ display: "" });
        this.emitEvent("remove", [this]);
      };
      proto.remove = function() {
        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
          this.removeElem();
          return;
        }
        this.once("transitionEnd", function() {
          this.removeElem();
        });
        this.hide();
      };
      proto.reveal = function() {
        delete this.isHidden;
        this.css({ display: "" });
        var options = this.layout.options;
        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty("visibleStyle");
        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;
        this.transition({
          from: options.hiddenStyle,
          to: options.visibleStyle,
          isCleaning: true,
          onTransitionEnd
        });
      };
      proto.onRevealTransitionEnd = function() {
        if (!this.isHidden) {
          this.emitEvent("reveal");
        }
      };
      proto.getHideRevealTransitionEndProperty = function(styleProperty) {
        var optionStyle = this.layout.options[styleProperty];
        if (optionStyle.opacity) {
          return "opacity";
        }
        for (var prop in optionStyle) {
          return prop;
        }
      };
      proto.hide = function() {
        this.isHidden = true;
        this.css({ display: "" });
        var options = this.layout.options;
        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty("hiddenStyle");
        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;
        this.transition({
          from: options.visibleStyle,
          to: options.hiddenStyle,
          // keep hidden stuff hidden
          isCleaning: true,
          onTransitionEnd
        });
      };
      proto.onHideTransitionEnd = function() {
        if (this.isHidden) {
          this.css({ display: "none" });
          this.emitEvent("hide");
        }
      };
      proto.destroy = function() {
        this.css({
          position: "",
          left: "",
          right: "",
          top: "",
          bottom: "",
          transition: "",
          transform: ""
        });
      };
      return Item;
    });
  }
});

// node_modules/outlayer/outlayer.js
var require_outlayer = __commonJS({
  "node_modules/outlayer/outlayer.js"(exports, module2) {
    (function(window2, factory) {
      "use strict";
      if (typeof define == "function" && define.amd) {
        define(
          [
            "ev-emitter/ev-emitter",
            "get-size/get-size",
            "fizzy-ui-utils/utils",
            "./item"
          ],
          function(EvEmitter, getSize, utils, Item) {
            return factory(window2, EvEmitter, getSize, utils, Item);
          }
        );
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory(
          window2,
          require_ev_emitter(),
          require_get_size(),
          require_utils(),
          require_item()
        );
      } else {
        window2.Outlayer = factory(
          window2,
          window2.EvEmitter,
          window2.getSize,
          window2.fizzyUIUtils,
          window2.Outlayer.Item
        );
      }
    })(window, function factory(window2, EvEmitter, getSize, utils, Item) {
      "use strict";
      var console2 = window2.console;
      var jQuery = window2.jQuery;
      var noop2 = function() {
      };
      var GUID = 0;
      var instances = {};
      function Outlayer(element2, options) {
        var queryElement = utils.getQueryElement(element2);
        if (!queryElement) {
          if (console2) {
            console2.error("Bad element for " + this.constructor.namespace + ": " + (queryElement || element2));
          }
          return;
        }
        this.element = queryElement;
        if (jQuery) {
          this.$element = jQuery(this.element);
        }
        this.options = utils.extend({}, this.constructor.defaults);
        this.option(options);
        var id = ++GUID;
        this.element.outlayerGUID = id;
        instances[id] = this;
        this._create();
        var isInitLayout = this._getOption("initLayout");
        if (isInitLayout) {
          this.layout();
        }
      }
      Outlayer.namespace = "outlayer";
      Outlayer.Item = Item;
      Outlayer.defaults = {
        containerStyle: {
          position: "relative"
        },
        initLayout: true,
        originLeft: true,
        originTop: true,
        resize: true,
        resizeContainer: true,
        // item options
        transitionDuration: "0.4s",
        hiddenStyle: {
          opacity: 0,
          transform: "scale(0.001)"
        },
        visibleStyle: {
          opacity: 1,
          transform: "scale(1)"
        }
      };
      var proto = Outlayer.prototype;
      utils.extend(proto, EvEmitter.prototype);
      proto.option = function(opts) {
        utils.extend(this.options, opts);
      };
      proto._getOption = function(option) {
        var oldOption = this.constructor.compatOptions[option];
        return oldOption && this.options[oldOption] !== void 0 ? this.options[oldOption] : this.options[option];
      };
      Outlayer.compatOptions = {
        // currentName: oldName
        initLayout: "isInitLayout",
        horizontal: "isHorizontal",
        layoutInstant: "isLayoutInstant",
        originLeft: "isOriginLeft",
        originTop: "isOriginTop",
        resize: "isResizeBound",
        resizeContainer: "isResizingContainer"
      };
      proto._create = function() {
        this.reloadItems();
        this.stamps = [];
        this.stamp(this.options.stamp);
        utils.extend(this.element.style, this.options.containerStyle);
        var canBindResize = this._getOption("resize");
        if (canBindResize) {
          this.bindResize();
        }
      };
      proto.reloadItems = function() {
        this.items = this._itemize(this.element.children);
      };
      proto._itemize = function(elems) {
        var itemElems = this._filterFindItemElements(elems);
        var Item2 = this.constructor.Item;
        var items = [];
        for (var i = 0; i < itemElems.length; i++) {
          var elem = itemElems[i];
          var item = new Item2(elem, this);
          items.push(item);
        }
        return items;
      };
      proto._filterFindItemElements = function(elems) {
        return utils.filterFindElements(elems, this.options.itemSelector);
      };
      proto.getItemElements = function() {
        return this.items.map(function(item) {
          return item.element;
        });
      };
      proto.layout = function() {
        this._resetLayout();
        this._manageStamps();
        var layoutInstant = this._getOption("layoutInstant");
        var isInstant = layoutInstant !== void 0 ? layoutInstant : !this._isLayoutInited;
        this.layoutItems(this.items, isInstant);
        this._isLayoutInited = true;
      };
      proto._init = proto.layout;
      proto._resetLayout = function() {
        this.getSize();
      };
      proto.getSize = function() {
        this.size = getSize(this.element);
      };
      proto._getMeasurement = function(measurement, size) {
        var option = this.options[measurement];
        var elem;
        if (!option) {
          this[measurement] = 0;
        } else {
          if (typeof option == "string") {
            elem = this.element.querySelector(option);
          } else if (option instanceof HTMLElement) {
            elem = option;
          }
          this[measurement] = elem ? getSize(elem)[size] : option;
        }
      };
      proto.layoutItems = function(items, isInstant) {
        items = this._getItemsForLayout(items);
        this._layoutItems(items, isInstant);
        this._postLayout();
      };
      proto._getItemsForLayout = function(items) {
        return items.filter(function(item) {
          return !item.isIgnored;
        });
      };
      proto._layoutItems = function(items, isInstant) {
        this._emitCompleteOnItems("layout", items);
        if (!items || !items.length) {
          return;
        }
        var queue = [];
        items.forEach(function(item) {
          var position = this._getItemLayoutPosition(item);
          position.item = item;
          position.isInstant = isInstant || item.isLayoutInstant;
          queue.push(position);
        }, this);
        this._processLayoutQueue(queue);
      };
      proto._getItemLayoutPosition = function() {
        return {
          x: 0,
          y: 0
        };
      };
      proto._processLayoutQueue = function(queue) {
        this.updateStagger();
        queue.forEach(function(obj, i) {
          this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
        }, this);
      };
      proto.updateStagger = function() {
        var stagger = this.options.stagger;
        if (stagger === null || stagger === void 0) {
          this.stagger = 0;
          return;
        }
        this.stagger = getMilliseconds(stagger);
        return this.stagger;
      };
      proto._positionItem = function(item, x, y, isInstant, i) {
        if (isInstant) {
          item.goTo(x, y);
        } else {
          item.stagger(i * this.stagger);
          item.moveTo(x, y);
        }
      };
      proto._postLayout = function() {
        this.resizeContainer();
      };
      proto.resizeContainer = function() {
        var isResizingContainer = this._getOption("resizeContainer");
        if (!isResizingContainer) {
          return;
        }
        var size = this._getContainerSize();
        if (size) {
          this._setContainerMeasure(size.width, true);
          this._setContainerMeasure(size.height, false);
        }
      };
      proto._getContainerSize = noop2;
      proto._setContainerMeasure = function(measure, isWidth) {
        if (measure === void 0) {
          return;
        }
        var elemSize = this.size;
        if (elemSize.isBorderBox) {
          measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;
        }
        measure = Math.max(measure, 0);
        this.element.style[isWidth ? "width" : "height"] = measure + "px";
      };
      proto._emitCompleteOnItems = function(eventName, items) {
        var _this = this;
        function onComplete() {
          _this.dispatchEvent(eventName + "Complete", null, [items]);
        }
        var count = items.length;
        if (!items || !count) {
          onComplete();
          return;
        }
        var doneCount = 0;
        function tick2() {
          doneCount++;
          if (doneCount == count) {
            onComplete();
          }
        }
        items.forEach(function(item) {
          item.once(eventName, tick2);
        });
      };
      proto.dispatchEvent = function(type, event, args) {
        var emitArgs = event ? [event].concat(args) : args;
        this.emitEvent(type, emitArgs);
        if (jQuery) {
          this.$element = this.$element || jQuery(this.element);
          if (event) {
            var $event = jQuery.Event(event);
            $event.type = type;
            this.$element.trigger($event, args);
          } else {
            this.$element.trigger(type, args);
          }
        }
      };
      proto.ignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
          item.isIgnored = true;
        }
      };
      proto.unignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
          delete item.isIgnored;
        }
      };
      proto.stamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
          return;
        }
        this.stamps = this.stamps.concat(elems);
        elems.forEach(this.ignore, this);
      };
      proto.unstamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
          return;
        }
        elems.forEach(function(elem) {
          utils.removeFrom(this.stamps, elem);
          this.unignore(elem);
        }, this);
      };
      proto._find = function(elems) {
        if (!elems) {
          return;
        }
        if (typeof elems == "string") {
          elems = this.element.querySelectorAll(elems);
        }
        elems = utils.makeArray(elems);
        return elems;
      };
      proto._manageStamps = function() {
        if (!this.stamps || !this.stamps.length) {
          return;
        }
        this._getBoundingRect();
        this.stamps.forEach(this._manageStamp, this);
      };
      proto._getBoundingRect = function() {
        var boundingRect = this.element.getBoundingClientRect();
        var size = this.size;
        this._boundingRect = {
          left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
          top: boundingRect.top + size.paddingTop + size.borderTopWidth,
          right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
          bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
        };
      };
      proto._manageStamp = noop2;
      proto._getElementOffset = function(elem) {
        var boundingRect = elem.getBoundingClientRect();
        var thisRect = this._boundingRect;
        var size = getSize(elem);
        var offset = {
          left: boundingRect.left - thisRect.left - size.marginLeft,
          top: boundingRect.top - thisRect.top - size.marginTop,
          right: thisRect.right - boundingRect.right - size.marginRight,
          bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
        };
        return offset;
      };
      proto.handleEvent = utils.handleEvent;
      proto.bindResize = function() {
        window2.addEventListener("resize", this);
        this.isResizeBound = true;
      };
      proto.unbindResize = function() {
        window2.removeEventListener("resize", this);
        this.isResizeBound = false;
      };
      proto.onresize = function() {
        this.resize();
      };
      utils.debounceMethod(Outlayer, "onresize", 100);
      proto.resize = function() {
        if (!this.isResizeBound || !this.needsResizeLayout()) {
          return;
        }
        this.layout();
      };
      proto.needsResizeLayout = function() {
        var size = getSize(this.element);
        var hasSizes = this.size && size;
        return hasSizes && size.innerWidth !== this.size.innerWidth;
      };
      proto.addItems = function(elems) {
        var items = this._itemize(elems);
        if (items.length) {
          this.items = this.items.concat(items);
        }
        return items;
      };
      proto.appended = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
          return;
        }
        this.layoutItems(items, true);
        this.reveal(items);
      };
      proto.prepended = function(elems) {
        var items = this._itemize(elems);
        if (!items.length) {
          return;
        }
        var previousItems = this.items.slice(0);
        this.items = items.concat(previousItems);
        this._resetLayout();
        this._manageStamps();
        this.layoutItems(items, true);
        this.reveal(items);
        this.layoutItems(previousItems);
      };
      proto.reveal = function(items) {
        this._emitCompleteOnItems("reveal", items);
        if (!items || !items.length) {
          return;
        }
        var stagger = this.updateStagger();
        items.forEach(function(item, i) {
          item.stagger(i * stagger);
          item.reveal();
        });
      };
      proto.hide = function(items) {
        this._emitCompleteOnItems("hide", items);
        if (!items || !items.length) {
          return;
        }
        var stagger = this.updateStagger();
        items.forEach(function(item, i) {
          item.stagger(i * stagger);
          item.hide();
        });
      };
      proto.revealItemElements = function(elems) {
        var items = this.getItems(elems);
        this.reveal(items);
      };
      proto.hideItemElements = function(elems) {
        var items = this.getItems(elems);
        this.hide(items);
      };
      proto.getItem = function(elem) {
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          if (item.element == elem) {
            return item;
          }
        }
      };
      proto.getItems = function(elems) {
        elems = utils.makeArray(elems);
        var items = [];
        elems.forEach(function(elem) {
          var item = this.getItem(elem);
          if (item) {
            items.push(item);
          }
        }, this);
        return items;
      };
      proto.remove = function(elems) {
        var removeItems = this.getItems(elems);
        this._emitCompleteOnItems("remove", removeItems);
        if (!removeItems || !removeItems.length) {
          return;
        }
        removeItems.forEach(function(item) {
          item.remove();
          utils.removeFrom(this.items, item);
        }, this);
      };
      proto.destroy = function() {
        var style = this.element.style;
        style.height = "";
        style.position = "";
        style.width = "";
        this.items.forEach(function(item) {
          item.destroy();
        });
        this.unbindResize();
        var id = this.element.outlayerGUID;
        delete instances[id];
        delete this.element.outlayerGUID;
        if (jQuery) {
          jQuery.removeData(this.element, this.constructor.namespace);
        }
      };
      Outlayer.data = function(elem) {
        elem = utils.getQueryElement(elem);
        var id = elem && elem.outlayerGUID;
        return id && instances[id];
      };
      Outlayer.create = function(namespace, options) {
        var Layout = subclass(Outlayer);
        Layout.defaults = utils.extend({}, Outlayer.defaults);
        utils.extend(Layout.defaults, options);
        Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);
        Layout.namespace = namespace;
        Layout.data = Outlayer.data;
        Layout.Item = subclass(Item);
        utils.htmlInit(Layout, namespace);
        if (jQuery && jQuery.bridget) {
          jQuery.bridget(namespace, Layout);
        }
        return Layout;
      };
      function subclass(Parent) {
        function SubClass() {
          Parent.apply(this, arguments);
        }
        SubClass.prototype = Object.create(Parent.prototype);
        SubClass.prototype.constructor = SubClass;
        return SubClass;
      }
      var msUnits = {
        ms: 1,
        s: 1e3
      };
      function getMilliseconds(time) {
        if (typeof time == "number") {
          return time;
        }
        var matches = time.match(/(^\d*\.?\d*)(\w*)/);
        var num = matches && matches[1];
        var unit = matches && matches[2];
        if (!num.length) {
          return 0;
        }
        num = parseFloat(num);
        var mult = msUnits[unit] || 1;
        return num * mult;
      }
      Outlayer.Item = Item;
      return Outlayer;
    });
  }
});

// node_modules/masonry-layout/masonry.js
var require_masonry = __commonJS({
  "node_modules/masonry-layout/masonry.js"(exports, module2) {
    (function(window2, factory) {
      if (typeof define == "function" && define.amd) {
        define(
          [
            "outlayer/outlayer",
            "get-size/get-size"
          ],
          factory
        );
      } else if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory(
          require_outlayer(),
          require_get_size()
        );
      } else {
        window2.Masonry = factory(
          window2.Outlayer,
          window2.getSize
        );
      }
    })(window, function factory(Outlayer, getSize) {
      "use strict";
      var Masonry2 = Outlayer.create("masonry");
      Masonry2.compatOptions.fitWidth = "isFitWidth";
      var proto = Masonry2.prototype;
      proto._resetLayout = function() {
        this.getSize();
        this._getMeasurement("columnWidth", "outerWidth");
        this._getMeasurement("gutter", "outerWidth");
        this.measureColumns();
        this.colYs = [];
        for (var i = 0; i < this.cols; i++) {
          this.colYs.push(0);
        }
        this.maxY = 0;
        this.horizontalColIndex = 0;
      };
      proto.measureColumns = function() {
        this.getContainerWidth();
        if (!this.columnWidth) {
          var firstItem = this.items[0];
          var firstItemElem = firstItem && firstItem.element;
          this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || // if first elem has no width, default to size of container
          this.containerWidth;
        }
        var columnWidth = this.columnWidth += this.gutter;
        var containerWidth = this.containerWidth + this.gutter;
        var cols = containerWidth / columnWidth;
        var excess = columnWidth - containerWidth % columnWidth;
        var mathMethod = excess && excess < 1 ? "round" : "floor";
        cols = Math[mathMethod](cols);
        this.cols = Math.max(cols, 1);
      };
      proto.getContainerWidth = function() {
        var isFitWidth = this._getOption("fitWidth");
        var container = isFitWidth ? this.element.parentNode : this.element;
        var size = getSize(container);
        this.containerWidth = size && size.innerWidth;
      };
      proto._getItemLayoutPosition = function(item) {
        item.getSize();
        var remainder = item.size.outerWidth % this.columnWidth;
        var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
        var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
        colSpan = Math.min(colSpan, this.cols);
        var colPosMethod = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition";
        var colPosition = this[colPosMethod](colSpan, item);
        var position = {
          x: this.columnWidth * colPosition.col,
          y: colPosition.y
        };
        var setHeight = colPosition.y + item.size.outerHeight;
        var setMax = colSpan + colPosition.col;
        for (var i = colPosition.col; i < setMax; i++) {
          this.colYs[i] = setHeight;
        }
        return position;
      };
      proto._getTopColPosition = function(colSpan) {
        var colGroup = this._getTopColGroup(colSpan);
        var minimumY = Math.min.apply(Math, colGroup);
        return {
          col: colGroup.indexOf(minimumY),
          y: minimumY
        };
      };
      proto._getTopColGroup = function(colSpan) {
        if (colSpan < 2) {
          return this.colYs;
        }
        var colGroup = [];
        var groupCount = this.cols + 1 - colSpan;
        for (var i = 0; i < groupCount; i++) {
          colGroup[i] = this._getColGroupY(i, colSpan);
        }
        return colGroup;
      };
      proto._getColGroupY = function(col, colSpan) {
        if (colSpan < 2) {
          return this.colYs[col];
        }
        var groupColYs = this.colYs.slice(col, col + colSpan);
        return Math.max.apply(Math, groupColYs);
      };
      proto._getHorizontalColPosition = function(colSpan, item) {
        var col = this.horizontalColIndex % this.cols;
        var isOver = colSpan > 1 && col + colSpan > this.cols;
        col = isOver ? 0 : col;
        var hasSize = item.size.outerWidth && item.size.outerHeight;
        this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
        return {
          col,
          y: this._getColGroupY(col, colSpan)
        };
      };
      proto._manageStamp = function(stamp) {
        var stampSize = getSize(stamp);
        var offset = this._getElementOffset(stamp);
        var isOriginLeft = this._getOption("originLeft");
        var firstX = isOriginLeft ? offset.left : offset.right;
        var lastX = firstX + stampSize.outerWidth;
        var firstCol = Math.floor(firstX / this.columnWidth);
        firstCol = Math.max(0, firstCol);
        var lastCol = Math.floor(lastX / this.columnWidth);
        lastCol -= lastX % this.columnWidth ? 0 : 1;
        lastCol = Math.min(this.cols - 1, lastCol);
        var isOriginTop = this._getOption("originTop");
        var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
        for (var i = firstCol; i <= lastCol; i++) {
          this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
        }
      };
      proto._getContainerSize = function() {
        this.maxY = Math.max.apply(Math, this.colYs);
        var size = {
          height: this.maxY
        };
        if (this._getOption("fitWidth")) {
          size.width = this._getContainerFitWidth();
        }
        return size;
      };
      proto._getContainerFitWidth = function() {
        var unusedCols = 0;
        var i = this.cols;
        while (--i) {
          if (this.colYs[i] !== 0) {
            break;
          }
          unusedCols++;
        }
        return (this.cols - unusedCols) * this.columnWidth - this.gutter;
      };
      proto.needsResizeLayout = function() {
        var previousWidth = this.containerWidth;
        this.getContainerWidth();
        return previousWidth != this.containerWidth;
      };
      return Masonry2;
    });
  }
});

// node_modules/imagesloaded/node_modules/ev-emitter/ev-emitter.js
var require_ev_emitter2 = __commonJS({
  "node_modules/imagesloaded/node_modules/ev-emitter/ev-emitter.js"(exports, module2) {
    (function(global2, factory) {
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory();
      } else {
        global2.EvEmitter = factory();
      }
    })(typeof window != "undefined" ? window : exports, function() {
      function EvEmitter() {
      }
      let proto = EvEmitter.prototype;
      proto.on = function(eventName, listener) {
        if (!eventName || !listener) return this;
        let events = this._events = this._events || {};
        let listeners = events[eventName] = events[eventName] || [];
        if (!listeners.includes(listener)) {
          listeners.push(listener);
        }
        return this;
      };
      proto.once = function(eventName, listener) {
        if (!eventName || !listener) return this;
        this.on(eventName, listener);
        let onceEvents = this._onceEvents = this._onceEvents || {};
        let onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
        onceListeners[listener] = true;
        return this;
      };
      proto.off = function(eventName, listener) {
        let listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length) return this;
        let index = listeners.indexOf(listener);
        if (index != -1) {
          listeners.splice(index, 1);
        }
        return this;
      };
      proto.emitEvent = function(eventName, args) {
        let listeners = this._events && this._events[eventName];
        if (!listeners || !listeners.length) return this;
        listeners = listeners.slice(0);
        args = args || [];
        let onceListeners = this._onceEvents && this._onceEvents[eventName];
        for (let listener of listeners) {
          let isOnce = onceListeners && onceListeners[listener];
          if (isOnce) {
            this.off(eventName, listener);
            delete onceListeners[listener];
          }
          listener.apply(this, args);
        }
        return this;
      };
      proto.allOff = function() {
        delete this._events;
        delete this._onceEvents;
        return this;
      };
      return EvEmitter;
    });
  }
});

// node_modules/imagesloaded/imagesloaded.js
var require_imagesloaded = __commonJS({
  "node_modules/imagesloaded/imagesloaded.js"(exports, module2) {
    (function(window2, factory) {
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = factory(window2, require_ev_emitter2());
      } else {
        window2.imagesLoaded = factory(window2, window2.EvEmitter);
      }
    })(
      typeof window !== "undefined" ? window : exports,
      function factory(window2, EvEmitter) {
        let $ = window2.jQuery;
        let console2 = window2.console;
        function makeArray(obj) {
          if (Array.isArray(obj)) return obj;
          let isArrayLike = typeof obj == "object" && typeof obj.length == "number";
          if (isArrayLike) return [...obj];
          return [obj];
        }
        function ImagesLoaded(elem, options, onAlways) {
          if (!(this instanceof ImagesLoaded)) {
            return new ImagesLoaded(elem, options, onAlways);
          }
          let queryElem = elem;
          if (typeof elem == "string") {
            queryElem = document.querySelectorAll(elem);
          }
          if (!queryElem) {
            console2.error(`Bad element for imagesLoaded ${queryElem || elem}`);
            return;
          }
          this.elements = makeArray(queryElem);
          this.options = {};
          if (typeof options == "function") {
            onAlways = options;
          } else {
            Object.assign(this.options, options);
          }
          if (onAlways) this.on("always", onAlways);
          this.getImages();
          if ($) this.jqDeferred = new $.Deferred();
          setTimeout(this.check.bind(this));
        }
        ImagesLoaded.prototype = Object.create(EvEmitter.prototype);
        ImagesLoaded.prototype.getImages = function() {
          this.images = [];
          this.elements.forEach(this.addElementImages, this);
        };
        const elementNodeTypes = [1, 9, 11];
        ImagesLoaded.prototype.addElementImages = function(elem) {
          if (elem.nodeName === "IMG") {
            this.addImage(elem);
          }
          if (this.options.background === true) {
            this.addElementBackgroundImages(elem);
          }
          let { nodeType } = elem;
          if (!nodeType || !elementNodeTypes.includes(nodeType)) return;
          let childImgs = elem.querySelectorAll("img");
          for (let img of childImgs) {
            this.addImage(img);
          }
          if (typeof this.options.background == "string") {
            let children2 = elem.querySelectorAll(this.options.background);
            for (let child of children2) {
              this.addElementBackgroundImages(child);
            }
          }
        };
        const reURL = /url\((['"])?(.*?)\1\)/gi;
        ImagesLoaded.prototype.addElementBackgroundImages = function(elem) {
          let style = getComputedStyle(elem);
          if (!style) return;
          let matches = reURL.exec(style.backgroundImage);
          while (matches !== null) {
            let url = matches && matches[2];
            if (url) {
              this.addBackground(url, elem);
            }
            matches = reURL.exec(style.backgroundImage);
          }
        };
        ImagesLoaded.prototype.addImage = function(img) {
          let loadingImage = new LoadingImage(img);
          this.images.push(loadingImage);
        };
        ImagesLoaded.prototype.addBackground = function(url, elem) {
          let background = new Background(url, elem);
          this.images.push(background);
        };
        ImagesLoaded.prototype.check = function() {
          this.progressedCount = 0;
          this.hasAnyBroken = false;
          if (!this.images.length) {
            this.complete();
            return;
          }
          let onProgress = (image, elem, message) => {
            setTimeout(() => {
              this.progress(image, elem, message);
            });
          };
          this.images.forEach(function(loadingImage) {
            loadingImage.once("progress", onProgress);
            loadingImage.check();
          });
        };
        ImagesLoaded.prototype.progress = function(image, elem, message) {
          this.progressedCount++;
          this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
          this.emitEvent("progress", [this, image, elem]);
          if (this.jqDeferred && this.jqDeferred.notify) {
            this.jqDeferred.notify(this, image);
          }
          if (this.progressedCount === this.images.length) {
            this.complete();
          }
          if (this.options.debug && console2) {
            console2.log(`progress: ${message}`, image, elem);
          }
        };
        ImagesLoaded.prototype.complete = function() {
          let eventName = this.hasAnyBroken ? "fail" : "done";
          this.isComplete = true;
          this.emitEvent(eventName, [this]);
          this.emitEvent("always", [this]);
          if (this.jqDeferred) {
            let jqMethod = this.hasAnyBroken ? "reject" : "resolve";
            this.jqDeferred[jqMethod](this);
          }
        };
        function LoadingImage(img) {
          this.img = img;
        }
        LoadingImage.prototype = Object.create(EvEmitter.prototype);
        LoadingImage.prototype.check = function() {
          let isComplete = this.getIsImageComplete();
          if (isComplete) {
            this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
            return;
          }
          this.proxyImage = new Image();
          if (this.img.crossOrigin) {
            this.proxyImage.crossOrigin = this.img.crossOrigin;
          }
          this.proxyImage.addEventListener("load", this);
          this.proxyImage.addEventListener("error", this);
          this.img.addEventListener("load", this);
          this.img.addEventListener("error", this);
          this.proxyImage.src = this.img.currentSrc || this.img.src;
        };
        LoadingImage.prototype.getIsImageComplete = function() {
          return this.img.complete && this.img.naturalWidth;
        };
        LoadingImage.prototype.confirm = function(isLoaded, message) {
          this.isLoaded = isLoaded;
          let { parentNode } = this.img;
          let elem = parentNode.nodeName === "PICTURE" ? parentNode : this.img;
          this.emitEvent("progress", [this, elem, message]);
        };
        LoadingImage.prototype.handleEvent = function(event) {
          let method = "on" + event.type;
          if (this[method]) {
            this[method](event);
          }
        };
        LoadingImage.prototype.onload = function() {
          this.confirm(true, "onload");
          this.unbindEvents();
        };
        LoadingImage.prototype.onerror = function() {
          this.confirm(false, "onerror");
          this.unbindEvents();
        };
        LoadingImage.prototype.unbindEvents = function() {
          this.proxyImage.removeEventListener("load", this);
          this.proxyImage.removeEventListener("error", this);
          this.img.removeEventListener("load", this);
          this.img.removeEventListener("error", this);
        };
        function Background(url, element2) {
          this.url = url;
          this.element = element2;
          this.img = new Image();
        }
        Background.prototype = Object.create(LoadingImage.prototype);
        Background.prototype.check = function() {
          this.img.addEventListener("load", this);
          this.img.addEventListener("error", this);
          this.img.src = this.url;
          let isComplete = this.getIsImageComplete();
          if (isComplete) {
            this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
            this.unbindEvents();
          }
        };
        Background.prototype.unbindEvents = function() {
          this.img.removeEventListener("load", this);
          this.img.removeEventListener("error", this);
        };
        Background.prototype.confirm = function(isLoaded, message) {
          this.isLoaded = isLoaded;
          this.emitEvent("progress", [this, this.element, message]);
        };
        ImagesLoaded.makeJQueryPlugin = function(jQuery) {
          jQuery = jQuery || window2.jQuery;
          if (!jQuery) return;
          $ = jQuery;
          $.fn.imagesLoaded = function(options, onAlways) {
            let instance10 = new ImagesLoaded(this, options, onAlways);
            return instance10.jqDeferred.promise($(this));
          };
        };
        ImagesLoaded.makeJQueryPlugin();
        return ImagesLoaded;
      }
    );
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MediaCompanion
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");

// src/views/gallery-view.ts
var import_obsidian7 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src) tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
  value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/await_block.js
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token) return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i) => {
          if (i !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i] === block2) {
                info.blocks[i] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks) info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then(
      (value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      },
      (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      }
    );
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = /** @type {T} */
    promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance10, create_fragment10, not_equal, props, append_styles = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance10 ? instance10(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/stores/pluginStore.ts
var plugin = writable();
var pluginStore_default = { plugin };

// src/model/mediaFile.ts
var import_obsidian = require("obsidian");

// src/model/sidecar.ts
var _Sidecar = class _Sidecar {
  constructor() {
  }
  /**
      * Create a new sidecar file and link it to a media file
      * @param file The media file to link it to
      * @param app The app instance
      * @returns The created sidecar
      */
  static async create(mediaFile, app2, plugin2, f = null) {
    const file2 = new _Sidecar();
    file2.mediaFile = mediaFile;
    file2.app = app2;
    file2.plugin = plugin2;
    await file2.fill(f);
    return file2;
  }
  /**
      * Fill the sidecar with its metadata
      * @param file The media file to use for filling
      * @param app The app instance
      */
  async fill(f = null) {
    if (f) {
      this.file = f;
    } else {
      this.file = await this.createIfNotExists();
    }
    this.hideInAll();
  }
  /**
      * Create a sidecar file if it does not exist yet
      * @param app The app instance
      * @returns The already existing or newly created sidecar file
      */
  async createIfNotExists() {
    var _a;
    const file2 = (_a = this.app.vault.getFileByPath(`${this.mediaFile.path}${_Sidecar.EXTENSION}`)) != null ? _a : await this.app.vault.create(`${this.mediaFile.path}${_Sidecar.EXTENSION}`, this.plugin.settings.sidecarTemplate);
    return file2;
  }
  hideInAll() {
    const leaves = this.app.workspace.getLeavesOfType("file-explorer");
    for (const leaf of leaves) {
      this.hide(leaf);
    }
  }
  /**
   * Hides a sidecar from a given file explorer leaf
   * @param leaf The file explorer leaf the sidecar should be hidden form
   */
  hide(leaf) {
    var _a, _b, _c;
    if (!leaf) return;
    if (!((_a = leaf.view) == null ? void 0 : _a.fileItems)) return;
    const element2 = (_c = (_b = leaf.view) == null ? void 0 : _b.fileItems[this.file.path]) == null ? void 0 : _c.el;
    if (!element2) return;
    element2.hidden = get_store_value(pluginStore_default.plugin).settings.hideSidecar;
  }
  /**
      * Finds all tags in the file: Both the frontmatter and the body, and returns
      * them without duplicates and hashtags.
      * @returns The tags, without hashtags and duplicates
      */
  getTags() {
    var _a, _b, _c, _d;
    const cache = this.app.metadataCache.getFileCache(this.file);
    if (!cache) return [];
    let tags = (_b = (_a = cache.tags) == null ? void 0 : _a.map((t) => t.tag)) != null ? _b : [];
    const fmTags = (_d = (_c = cache.frontmatter) == null ? void 0 : _c.tags) != null ? _d : [];
    if (Array.isArray(fmTags)) {
      tags = tags.concat(fmTags);
    } else {
      tags.push(fmTags);
    }
    tags = tags.map((t) => t.toLowerCase());
    tags = [...new Set(tags)];
    return tags.map((t) => t.startsWith("#") ? t.slice(1) : t);
  }
  /**
      * Gets the information from a tag in the frontmatter
      * @param tag The tag to get from the frontmatter
      * @returns The data in the tag, or undefined if it does not exist
      */
  getFrontmatterTag(tag) {
    var _a;
    const cache = (_a = this.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.frontmatter;
    if (!cache) return void 0;
    return cache[tag];
  }
  /** 
      * Sets the information in a tag in the frontmatter
      * @param tag The tag to set in the frontmatter
      * @param value The value to set
      * @param type The type of the frontmatter tag
      */
  async setFrontmatterTag(tag, value, type = void 0) {
    try {
      await this.app.fileManager.processFrontMatter(this.file, (fm) => fm[tag] = value);
      if (type) {
        this.app.metadataTypeManager.properties[tag.toLowerCase()].type = type;
      }
    } catch (e) {
      console.error(e);
    }
  }
};
_Sidecar.EXTENSION = ".sidecar.md";
var Sidecar = _Sidecar;

// src/model/types/mediaTypes.ts
function getMediaType(extention) {
  switch (extention) {
    case "png":
    case "jpg":
    case "jpeg":
    case "webp":
    case "avif":
    case "bmp":
    case "gif":
      return "image" /* Image */;
    default:
      return "unknown" /* Unknown */;
  }
}

// src/model/mediaFile.ts
var _MediaFile = class _MediaFile {
  constructor() {
  }
  /**
      * Create a new MediaFile from a binary file
      * @param file The file to create a MediaFile from
      * @param app The app instance
   * @param sidecar The sidecar for the file, in case it already exists
      * @returns The created MediaFile
      */
  static async create(file2, app2, plugin2, sidecar = null) {
    const f = new _MediaFile();
    await _MediaFile.fill(f, file2, app2, plugin2, sidecar);
    return f;
  }
  /**
      * Fill the variables of the MediaFile
      * @param f The MediaFile to fill
      * @param file The related binary file
      * @param app The app instance
   * @param sidecar The sidecar for the file, in case it already exists
      */
  static async fill(f, file2, app2, plugin2, sidecar = null) {
    f.file = file2;
    f.app = app2;
    f.plugin = plugin2;
    f.sidecar = await Sidecar.create(file2, app2, plugin2, sidecar);
    await f.update();
  }
  /**
   * Finds the mediaType of the file based on the extension of the file
   * @returns The MediaType of the file
   */
  getType() {
    return getMediaType(this.file.extension);
  }
  /**
      * To be called when a file has been updated
      */
  async update() {
    const last_updated = this.sidecar.getFrontmatterTag(_MediaFile.last_updated_tag);
    if (!last_updated || last_updated < this.file.stat.mtime) {
      await this.sidecar.setFrontmatterTag(_MediaFile.last_updated_tag, /* @__PURE__ */ new Date(), "datetime");
    }
  }
};
_MediaFile.last_updated_tag = "MC-last-updated";
var MediaFile = _MediaFile;

// node_modules/extract-colors/lib/extract-colors.mjs
var Color = class _Color {
  /**
   * Set red, green and blue colors to create the Color object.
   */
  constructor(red, green, blue, hex = red << 16 | green << 8 | blue) {
    this._count = 1;
    this.__saturation = -1;
    this.__hue = -1;
    this.__lightness = -1;
    this.__intensity = -1;
    this._red = red;
    this._green = green;
    this._blue = blue;
    this._hex = hex;
  }
  /**
   * Distance between two colors.
   * - Minimum is 0 (between two same colors)
   * - Maximum is 1 (for example between black and white)
   */
  static distance(colorA, colorB) {
    return (Math.abs(colorB._red - colorA._red) + Math.abs(colorB._green - colorA._green) + Math.abs(colorB._blue - colorA._blue)) / (3 * 255);
  }
  clone() {
    const color = new _Color(this._red, this._green, this._blue, this._hex);
    color._count = this._count;
    return color;
  }
  updateHSL() {
    const red = this._red / 255;
    const green = this._green / 255;
    const blue = this._blue / 255;
    const max = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    this.__lightness = (max + min) / 2;
    if (max === min) {
      this.__hue = 0;
      this.__saturation = 0;
      this.__intensity = 0;
    } else {
      const distance2 = max - min;
      this.__saturation = this.__lightness > 0.5 ? distance2 / (2 - max - min) : distance2 / (max + min);
      this.__intensity = this.__saturation * ((0.5 - Math.abs(0.5 - this.__lightness)) * 2);
      switch (max) {
        case red:
          this.__hue = ((green - blue) / distance2 + (green < blue ? 6 : 0)) / 6;
          break;
        case green:
          this.__hue = ((blue - red) / distance2 + 2) / 6;
          break;
        case blue:
          this.__hue = ((red - green) / distance2 + 4) / 6;
          break;
      }
    }
  }
  /**
   * Hue from 0 to 1
   */
  get _hue() {
    if (this.__hue === -1) {
      this.updateHSL();
    }
    return this.__hue;
  }
  /**
   * Saturation from 0 to 1
   */
  get _saturation() {
    if (this.__saturation === -1) {
      this.updateHSL();
    }
    return this.__saturation;
  }
  /**
   * Lightness from 0 to 1
   */
  get _lightness() {
    if (this.__lightness === -1) {
      this.updateHSL();
    }
    return this.__lightness;
  }
  /**
   * Color intensity from 0 to 1
   */
  get _intensity() {
    if (this.__intensity === -1) {
      this.updateHSL();
    }
    return this.__intensity;
  }
};
var distance = (a, b) => Math.abs(a - b);
var hueDistance = (a, b) => Math.min(distance(a, b), distance((a + 0.5) % 1, (b + 0.5) % 1));
var AverageGroup = class {
  constructor() {
    this.colors = [];
    this._average = null;
  }
  addColor(color) {
    this.colors.push(color);
    this._average = null;
  }
  isSamePalette(color, hue, saturation, lightness) {
    for (let i = 0; i < this.colors.length; i++) {
      const currentColor = this.colors[i];
      const isSame = hueDistance(currentColor._hue, color._hue) < hue && distance(currentColor._saturation, color._saturation) < saturation && distance(currentColor._lightness, color._lightness) < lightness;
      if (!isSame) {
        return false;
      }
    }
    return true;
  }
  get average() {
    if (!this._average) {
      const { r, g, b } = this.colors.reduce((total2, color) => {
        total2.r += color._red;
        total2.g += color._green;
        total2.b += color._blue;
        return total2;
      }, { r: 0, g: 0, b: 0 });
      const total = this.colors.reduce((_count, color) => _count + color._count, 0);
      this._average = new Color(
        Math.round(r / this.colors.length),
        Math.round(g / this.colors.length),
        Math.round(b / this.colors.length)
      );
      this._average._count = total;
    }
    return this._average;
  }
};
var AverageManager = class {
  constructor(hue, saturation, lightness) {
    this._groups = [];
    this._hue = hue;
    this._saturation = saturation;
    this._lightness = lightness;
  }
  addColor(color) {
    const samePalette = this._groups.find((averageGroup) => averageGroup.isSamePalette(color, this._hue, this._saturation, this._lightness));
    if (samePalette) {
      samePalette.addColor(color);
    } else {
      const averageGroup = new AverageGroup();
      averageGroup.addColor(color);
      this._groups.push(averageGroup);
    }
  }
  getGroups() {
    return this._groups.map((averageGroup) => averageGroup.average);
  }
};
var sortColors = (list, _pixels, _hueDistance, _saturationDistance, _lightnessDistance) => {
  const averageManager = new AverageManager(_hueDistance, _saturationDistance, _lightnessDistance);
  list.forEach((color) => averageManager.addColor(color));
  const sorted = averageManager.getGroups();
  sorted.sort((a, b) => {
    const bPower = (b._intensity + 0.1) * (0.9 - b._count / _pixels);
    const aPower = (a._intensity + 0.1) * (0.9 - a._count / _pixels);
    return bPower - aPower;
  });
  return sorted;
};
var createFinalColor = (color, pixels) => {
  return {
    hex: `#${"0".repeat(6 - color._hex.toString(16).length)}${color._hex.toString(16)}`,
    red: color._red,
    green: color._green,
    blue: color._blue,
    area: color._count / pixels,
    hue: color._hue,
    saturation: color._saturation,
    lightness: color._lightness,
    intensity: color._intensity
  };
};
var cleanInputs = ({
  pixels = 64e3,
  distance: distance2 = 0.22,
  colorValidator = (_red, _green, _blue, _alpha) => (_alpha != null ? _alpha : 255) > 250,
  hueDistance: hueDistance2 = 0.08333333333333333,
  saturationDistance = 0.2,
  lightnessDistance = 0.2,
  crossOrigin = null
} = {}) => {
  if (true) {
    const testUint = (label, val, min = 0, max = Number.MAX_SAFE_INTEGER) => {
      if (!Number.isInteger(val)) {
        throw new Error(`${label} is not a valid number (${val})`);
      }
      if (val < min) {
        console.warn(`${label} can not be less than ${min} (it's ${val})`);
      }
      if (val > max) {
        console.warn(`${label} can not be more than ${max} (it's ${val})`);
      }
      return Math.min(Math.max(val, min), max);
    };
    const testNumber = (label, val, min = 0, max = Number.MAX_VALUE) => {
      if (Number(val) !== val) {
        throw new Error(`${label} is not a valid number (${val})`);
      }
      if (val < min) {
        console.warn(`${label} can not be less than ${min} (it's ${val})`);
      }
      if (val > max) {
        console.warn(`${label} can not be more than ${max} (it's ${val})`);
      }
      return Math.min(Math.max(val, min), max);
    };
    const testFunction = (label, val) => {
      if (!val || {}.toString.call(val) !== "[object Function]") {
        throw new Error(`${label} is not a function (${val})`);
      }
      return val;
    };
    testUint("pixels", pixels || 0, 1);
    testNumber("distance", distance2, 0, 1);
    testFunction("colorValidator", colorValidator);
    testNumber("hueDistance", hueDistance2, 0, 1);
    testNumber("saturationDistance", saturationDistance, 0, 1);
    testNumber("lightnessDistance", lightnessDistance, 0, 1);
  }
  return [
    Math.max(pixels, 1),
    Math.min(Math.max(distance2, 0), 1),
    colorValidator,
    Math.min(Math.max(hueDistance2, 0), 1),
    Math.min(Math.max(saturationDistance, 0), 1),
    Math.min(Math.max(lightnessDistance, 0), 1),
    crossOrigin
  ];
};
var LeafGroup = class {
  /**
   * Store colors or groups and _count similiar groups in the image.
   */
  constructor() {
    this._count = 0;
    this._children = {};
  }
  /**
   * Add color to the group.
   * 
   * @param _hex Hexadecimal value of the color
   * @param _red Red chanel amount of the color
   * @param _green Green chanel amount of the color
   * @param _blue Blue chanel amount of the color
   * @returns The color
   */
  addColor(_hex, _red, _green, _blue) {
    this._count++;
    if (this._children[_hex]) {
      this._children[_hex]._count++;
    } else {
      this._children[_hex] = new Color(_red, _green, _blue, _hex);
    }
    return this._children[_hex];
  }
  /**
   * Get list of groups of list of colors.
   * 
   * @returns List of colors
   */
  getList() {
    return Object.keys(this._children).map((key) => this._children[key]);
  }
  /**
   * Representative color of leaf.
   * 
   * @returns Main color of the leaf
   */
  createMainColor() {
    const list = this.getList();
    const biggest = list.reduce((a, b) => a._count >= b._count ? a : b);
    const main = biggest.clone();
    main._count = this._count;
    return main;
  }
};
var RootGroup = class {
  /**
   * Store colors or groups and _count similiar groups in the image.
   */
  constructor() {
    this._count = 0;
    this._children = {};
  }
  /**
   * Get list of groups of list of colors.
   */
  getList() {
    return Object.keys(this._children).map((key) => this._children[key]);
  }
  addColor(r, g, b) {
    const full = r << 16 | g << 8 | b;
    const loss = (r >> 4 & 15) << 8 | (g >> 4 & 15) << 4 | b >> 4 & 15;
    this._count++;
    return this.getLeafGroup(loss).addColor(full, r, g, b);
  }
  /**
   * Add a key for a color, this key is a simplification to find neighboring colors.
   * Neighboring colors has same key.
   */
  getLeafGroup(key) {
    if (!this._children[key]) {
      this._children[key] = new LeafGroup();
    }
    return this._children[key];
  }
  /**
   * List of colors sorted by importance (neighboring hare calculated by distance and removed).
   * Importance is calculated with the saturation and _count of neighboring colors.
   */
  getColors(_distance) {
    const list = this.getList().map((child) => child.createMainColor());
    list.sort((a, b) => b._count - a._count);
    const newList = [];
    while (list.length) {
      const current = list.shift();
      list.filter((color) => Color.distance(current, color) < _distance).forEach((near) => {
        current._count += near._count;
        const i = list.findIndex((color) => color === near);
        list.splice(i, 1);
      });
      newList.push(current);
    }
    return newList;
  }
};
var extractor = ({ data, width, height }, _pixels, _distance, _colorValidator) => {
  const colorGroup = new RootGroup();
  const reducer = width && height ? Math.floor(width * height / _pixels) || 1 : 1;
  let ignoredColorsCount = 0;
  for (let i = 0; i < data.length; i += 4 * reducer) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];
    if (_colorValidator(r, g, b, a)) {
      colorGroup.addColor(r, g, b);
    } else {
      ignoredColorsCount++;
    }
  }
  return {
    colors: colorGroup.getColors(_distance),
    count: colorGroup._count + ignoredColorsCount
  };
};
var _isBrowser = () => typeof window !== "undefined";
var _sortFinalColors = (_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance) => {
  const list = sortColors(_colors, _pixels, _hueDistance, _saturationDistance, _lightnessDistance);
  return list.map((color) => createFinalColor(color, _pixels));
};
var _getImageData = (_image, _pixels) => {
  const currentPixels = _image.width * _image.height;
  const width = currentPixels < _pixels ? _image.width : Math.round(_image.width * Math.sqrt(_pixels / currentPixels));
  const height = currentPixels < _pixels ? _image.height : Math.round(_image.height * Math.sqrt(_pixels / currentPixels));
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");
  context.drawImage(_image, 0, 0, _image.width, _image.height, 0, 0, width, height);
  return context.getImageData(0, 0, width, height);
};
var extractColorsFromImageData = (imageData, options = {}) => {
  const [_pixels, _distance, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance] = cleanInputs(options);
  const { colors, count } = extractor(imageData, _pixels, _distance, _colorValidator);
  return _sortFinalColors(colors, count, _hueDistance, _saturationDistance, _lightnessDistance);
};
var extractColorsFromImage = (image, options = {}) => {
  if (_isBrowser()) {
    const [_pixels, _distance, _colorValidator, _hueDistance, _saturationDistance, _lightnessDistance, _crossOrigin] = cleanInputs(options);
    image.crossOrigin = _crossOrigin;
    return new Promise((resolve) => {
      const extract = (image2) => {
        const imageData = _getImageData(image2, _pixels);
        const { colors, count } = extractor(imageData, _pixels, _distance, _colorValidator);
        resolve(_sortFinalColors(colors, count, _hueDistance, _saturationDistance, _lightnessDistance));
      };
      if (image.complete) {
        extract(image);
      } else {
        const imageLoaded = () => {
          image.removeEventListener("load", imageLoaded);
          extract(image);
        };
        image.addEventListener("load", imageLoaded);
      }
    });
  } else {
    if (true) {
      throw new Error("Can not use extractColorsFromImage for Node.js");
    }
  }
};
var extractColorsFromSrc = (src, options = {}) => {
  if (_isBrowser()) {
    const image = new Image();
    image.src = src;
    return extractColorsFromImage(image, options);
  } else {
    if (true) {
      throw new Error("Can not use extractColorsFromSrc for Node.js");
    }
  }
};
var extractColors = (picture, options) => {
  if (_isBrowser()) {
    if (picture instanceof Image) {
      return extractColorsFromImage(picture, options);
    }
    if (picture instanceof ImageData || picture instanceof Object && picture.data) {
      return new Promise((resolve) => {
        resolve(extractColorsFromImageData(picture, options));
      });
    }
    if (typeof picture === "string") {
      return extractColorsFromSrc(picture, options);
    }
  } else {
    if (true) {
      if (picture instanceof String) {
        throw new Error("Send imageData to extractColors (Image src or HTMLImageElement not supported in Nodejs)");
      }
      if (!picture.data) {
        throw new Error("Send imageData to extractColors");
      }
      if (options == null ? void 0 : options.crossOrigin) {
        console.warn("options.crossOrigin not supported in Node.js");
      }
    }
    return new Promise((resolve) => {
      resolve(extractColorsFromImageData(picture, options));
    });
  }
  throw new Error(`Can not analyse picture`);
};

// src/model/types/image/image.ts
var _MCImage = class _MCImage extends MediaFile {
  constructor() {
    super();
  }
  /**
      * Create a new MCImage from a file: Use as constructor
      * @param file The file to create the image from
      * @param app The app instance
   * @param sidecar The sidecar file, if it already exists
      * @returns The created MCImage
      */
  static async create(file2, app2, plugin2, sidecar = null) {
    const f = new _MCImage();
    await _MCImage.fill(f, file2, app2, plugin2, sidecar);
    return f;
  }
  /**
      * Fill the properties of a file
      * @param f The file to fill
      * @param file The related binary file
      * @param app The app instance
   * @param sidecar The sidecar file, if it already exists
      */
  static async fill(f, file2, app2, plugin2, sidecar = null) {
    await super.fill(f, file2, app2, plugin2, sidecar);
  }
  /**
      * Extracts the colors from the image file
      * @returns The colors, in the format dictated by the extract-colors package
      */
  async readColors() {
    const extracted = await extractColors(
      this.app.vault.getResourcePath(this.file),
      // 1/4th of defualt pixels to speed up the proces
      { pixels: 16e3 }
    );
    const colors = [];
    for (const e of extracted) {
      colors.push({
        h: e.hue,
        s: e.saturation,
        l: e.lightness,
        area: e.area
      });
    }
    return colors;
  }
  /**
   * Finds the cahced colors of the image. If they aren't already registered,
   * they will be extracted and saved when this is called.
   * @returns The cached colors of the image
   */
  async getCachedColors() {
    if (!this.sidecar.getFrontmatterTag(_MCImage.colors_tag)) {
      await this.setColors();
    }
    return this.sidecar.getFrontmatterTag(_MCImage.colors_tag);
  }
  /**
   * Extracts and sets the colors for the image
   */
  async setColors() {
    const colors = await this.readColors();
    await this.sidecar.setFrontmatterTag(_MCImage.colors_tag, colors);
  }
  /**
      * Attempts to parse the given object as an array wit [width, height]. 
      * Returns undefined if failed
      * @param size An object potentially holding the width and height of an image
      * @returns The width and height object, undefined if not present
      */
  static parseSize(size) {
    if (!(size instanceof Array)) return void 0;
    if (size.length !== 2) return void 0;
    return { width: size[0], height: size[1] };
  }
  /**
      * Read the width and height from a binary image
      * @returns The size of the image
      */
  async readSize() {
    const image = new Image();
    image.src = this.app.vault.getResourcePath(this.file);
    await image.decode();
    return { width: image.naturalWidth, height: image.naturalHeight };
  }
  /**
   * Finds and returns the size of the image in pixels.
   * If there is no size in the cache yet, this will be computed when this is called.
   * @returns The cached size
   */
  async getCachedSize() {
    const value = this.sidecar.getFrontmatterTag(_MCImage.size_tag);
    if (!value || !_MCImage.parseSize(value)) {
      await this.setSize();
    }
    return _MCImage.parseSize(this.sidecar.getFrontmatterTag(_MCImage.size_tag));
  }
  /**
   * Finds and sets the size of the image to the cache
   */
  async setSize() {
    const size = await this.readSize();
    await this.sidecar.setFrontmatterTag(_MCImage.size_tag, [size.width, size.height]);
  }
  /**
      * To be called when the file is updated
      */
  async update() {
    const last_updated = this.sidecar.getFrontmatterTag(MediaFile.last_updated_tag);
    await this.getCachedColors();
    await this.getCachedSize();
    if (!last_updated || last_updated < this.file.stat.mtime) {
      await this.setColors();
      await this.setSize();
    }
    await super.update();
  }
};
// The reserved tags for this type
// when editing these, they should also be renamed in
// frontmatter.ts
_MCImage.size_tag = "MC-size";
_MCImage.colors_tag = "MC-colors";
var MCImage = _MCImage;

// src/cache.ts
var Cache = class {
  constructor(app2, plugin2) {
    this.paths = {};
    this.tags = {};
    this.extensions = {};
    // Whether there is files currently being added or removed from the cache
    this.building = false;
    this.initialized = false;
    this.files = [];
    this.app = app2;
    this.plugin = plugin2;
  }
  /**
   * Will wait in steps of 100ms until the cache is initialized
   */
  async awaitReady() {
    await this.initialize();
    if (this.building || !this.initialized) {
      while (this.building || !this.initialized) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
  }
  /**
      * Initialize the cache with all the (supported) files in the vault
      */
  async initialize() {
    if (this.initialized) return;
    if (this.building) {
      while (this.building) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      return;
    }
    this.building = true;
    while (this.app.metadataCache.inProgressTaskCount > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    let files = this.app.vault.getFiles();
    const timer = Date.now();
    const total_files = files.length;
    files = files.filter((f) => this.plugin.settings.extensions.contains(f.extension.toLowerCase()));
    console.debug(
      `%c[Media Companion]: %cBuilding cache with ${files.length} media files found of ${total_files} files total 
                   If this is the first time, this may take a while`,
      "color: #00b7eb",
      "color: inherit"
    );
    const notice = new Notice(`Building cache with ${files.length} media files found of ${total_files} files total
Processing may take a while if many new files have been added`, 0);
    let total_done = 0;
    for (const file2 of files) {
      let mediaFile;
      try {
        switch (getMediaType(file2.extension)) {
          case "image" /* Image */:
            mediaFile = await MCImage.create(file2, this.app, this.plugin);
            break;
          case "unknown" /* Unknown */:
          default:
            mediaFile = await MediaFile.create(file2, this.app, this.plugin);
            break;
        }
        this.addFile(mediaFile);
      } catch (e) {
        console.log(`Failed on ${file2.name}`);
        console.log(e);
      }
      total_done++;
      notice.setMessage(`Media Companion: ${total_done}/${files.length} files processed
Processing may take a while if many new files have been added`);
    }
    notice.hide();
    console.debug(
      `%c[Media Companion]: %cFinished building cache in ${(Date.now() - timer) / 1e3}s, ${this.files.length} files in cache`,
      "color: #00b7eb",
      "color: inherit"
    );
    this.initialized = true;
    this.building = false;
  }
  /**
   * Will add new files to the cache or remove unneeded ones.
   * Should be called whenever plugin.settings.extensions is changed.
   */
  async updateExtensions() {
    if (this.building) {
      while (this.building) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    this.building = true;
    this.files = this.files.filter((f) => this.plugin.settings.extensions.contains(f.file.extension.toLowerCase()));
    let files = this.app.vault.getFiles();
    files = files.filter((f) => this.plugin.settings.extensions.contains(f.extension.toLowerCase()));
    files = files.filter((f) => !this.files.filter((mf) => mf.file.path == f.path));
    const notice = new Notice(`Adding ${files.length} new files`, 0);
    let total_done = 0;
    for (const file2 of files) {
      let mediaFile;
      switch (getMediaType(file2.extension)) {
        case "image" /* Image */:
          mediaFile = await MCImage.create(file2, this.app, this.plugin);
          break;
        case "unknown" /* Unknown */:
        default:
          mediaFile = await MediaFile.create(file2, this.app, this.plugin);
          break;
      }
      this.addFile(mediaFile);
      total_done++;
      notice.setMessage(`Media Companion: ${total_done}/${files.length} new files added
Processing may take a while if many new files have been added`);
    }
    notice.hide();
    this.building = false;
  }
  /**
      * Add a file to the cache
      * @param file The file to add to the cache
      */
  addFile(file2) {
    var _a, _b;
    this.files.push(file2);
    if ((_a = file2.file.parent) == null ? void 0 : _a.path) {
      for (const path of this.getPathHierarchy((_b = file2.file.parent) == null ? void 0 : _b.path)) {
        this.addCounter(this.paths, path);
      }
    }
    this.addCounter(this.extensions, file2.file.extension);
    const tags = file2.sidecar.getTags();
    if (tags.length > 0) {
      for (const tag of tags) {
        for (const path of this.getPathHierarchy(tag)) {
          this.addCounter(this.tags, path);
        }
      }
    }
  }
  /**
      * Remove a file from the cache
      * @param file The file to remove
      * @returns Whether the operation removed a file or not
      */
  removeFile(file2) {
    var _a, _b;
    const mediaFile = this.files.find((f) => f.file === file2);
    if (mediaFile) {
      this.files = this.files.filter((f) => f.file !== file2);
      if ((_a = mediaFile.file.parent) == null ? void 0 : _a.path) {
        for (const path of this.getPathHierarchy((_b = mediaFile.file.parent) == null ? void 0 : _b.path)) {
          this.removeCounter(this.paths, path);
        }
      }
      this.removeCounter(this.extensions, mediaFile.file.extension);
      const tags = mediaFile.sidecar.getTags();
      if (tags.length > 0) {
        for (const tag of tags) {
          for (const path of this.getPathHierarchy(tag)) {
            this.removeCounter(this.tags, path);
          }
        }
      }
      return true;
    }
    return false;
  }
  fileMoved(file2, oldPath) {
    var _a, _b;
    if ((_a = file2.file.parent) == null ? void 0 : _a.path) {
      for (const path of this.getPathHierarchy((_b = file2.file.parent) == null ? void 0 : _b.path)) {
        this.addCounter(this.paths, path);
      }
    }
    for (const path of this.getPathHierarchy(oldPath)) {
      this.removeCounter(this.paths, path);
    }
  }
  sidecarUpdated(_) {
    this.tags = {};
    for (const mFile of this.files) {
      for (const tag of mFile.sidecar.getTags()) {
        for (const path of this.getPathHierarchy(tag)) {
          this.addCounter(this.tags, path);
        }
      }
    }
  }
  addCounter(counter, value) {
    if (counter[value]) {
      counter[value] += 1;
    } else {
      counter[value] = 1;
    }
  }
  removeCounter(counter, value) {
    if (counter[value]) {
      counter[value] -= 1;
      if (this.extensions[value] == 0) {
        delete this.extensions[value];
      }
    }
  }
  /**
   * Returns all parent paths for a given path, from root to full path
   * @param path The file path to process
   * @returns Array of path strings, from root to full path
   */
  getPathHierarchy(path) {
    if (!path) return [""];
    const segments = path.split("/");
    const paths = [];
    let currentPath = "";
    for (let i = 0; i < segments.length; i++) {
      if (currentPath && segments[i]) {
        currentPath += "/";
      }
      currentPath += segments[i];
      if (currentPath) {
        paths.push(currentPath);
      }
    }
    return paths;
  }
  /**
      * Get a file from the cache
      * @param path The path of the file to get from the cache
      * @returns The file if it exists in the cache, otherwise undefined
      */
  getFile(path) {
    return this.files.find((f) => f.file.path === path);
  }
  /**
      * Checks whether a file is a sidecar file managed by the plugin
      * @param file The file to validate
      * @returns Whether or not it is a sidecar file managed by the plugin
      */
  isSidecar(file2) {
    return this.isSidecarFromPath(file2.path);
  }
  isSidecarFromPath(path) {
    if (!path.endsWith(Sidecar.EXTENSION)) return false;
    const mediaPath = path.substring(0, path.length - Sidecar.EXTENSION.length);
    const mediaFile = this.getFile(mediaPath);
    return mediaFile !== void 0;
  }
  /**
   * Takes every file in the cache and calls the function to hide itself from the
   * given file explorer leaf.
   * @param leaf The file manager leaf to hide things from
   */
  async hideAll(leaf) {
    for (const file2 of this.files) {
      file2.sidecar.hide(leaf);
    }
  }
};

// src/model/types/shape.ts
function getShape(width, height) {
  if (width === height) {
    return "square" /* Square */;
  } else if (width > height) {
    return "horizontal" /* Horizontal */;
  } else {
    return "vertical" /* Vertical */;
  }
}

// src/query.ts
var OrderByOptions = /* @__PURE__ */ ((OrderByOptions2) => {
  OrderByOptions2["random"] = "random";
  OrderByOptions2["creationDate"] = "creationDate";
  OrderByOptions2["modifiedDate"] = "modifiedDate";
  OrderByOptions2["name"] = "name";
  return OrderByOptions2;
})(OrderByOptions || {});
var _Query = class _Query {
  constructor(cache, query = _Query.defaultQuery) {
    this.cache = cache;
    this.query = query;
    this.currentIndex = -1;
    this.totalFound = 0;
    this.files = [];
    this.anyFolderInclude = this.query.folders.included.length > 0;
    this.anyTagInclude = this.query.tags.included.length > 0;
    this.sortedFolders = [
      ...this.query.folders.included.map((folder) => [folder, true]),
      ...this.query.folders.excluded.map((folder) => [folder, false])
    ];
    this.sortedFolders.sort((a, b) => b[0].length - a[0].length);
    this.sortedTags = [
      ...this.query.tags.included.map((tags) => [tags, true]),
      ...this.query.tags.excluded.map((tags) => [tags, false])
    ];
    this.sortedTags.sort((a, b) => b[0].length - a[0].length);
  }
  /**
   * Orders the files in the query according to the
   * OrderByOptions field in the QueryDetails
   */
  orderFiles() {
    switch (this.query.orderBy) {
      case "creationDate" /* creationDate */:
        this.files.sort((a, b) => a.file.stat.ctime - b.file.stat.ctime);
        break;
      case "modifiedDate" /* modifiedDate */:
        this.files.sort((a, b) => a.file.stat.mtime - b.file.stat.mtime);
        break;
      case "name" /* name */:
        this.files.sort((a, b) => a.file.name.localeCompare(b.file.name));
        break;
      case "random" /* random */:
      default:
        this.files.sort(() => Math.random() - 0.5);
        break;
    }
    if (!this.query.orderIncreasing) {
      this.files.reverse();
    }
  }
  /**
   * Tests a given file and returns whether the file fits
   * the query
   * @param item The MediaFile to be tested
   * @returns Whether the file fits the query
   */
  async testFile(item) {
    const mediaTypes = this.determineTypes();
    if (mediaTypes.length > 0) {
      if (!mediaTypes.includes(item.getType())) return false;
    }
    if (this.query.fileTypes.included.length > 0 && !this.query.fileTypes.included.contains(item.file.extension)) return false;
    if (this.query.fileTypes.excluded.contains(item.file.extension)) return false;
    const DAY_LENGTH = 864e5;
    if (this.query.date.startCtime && this.query.date.endCtime && this.query.date.startCtime.getTime() < this.query.date.endCtime.getTime() + DAY_LENGTH && (item.file.stat.ctime < this.query.date.startCtime.getTime() || item.file.stat.ctime > this.query.date.endCtime.getTime() + DAY_LENGTH)) return false;
    if (this.query.date.startMtime && this.query.date.endMtime && this.query.date.startMtime.getTime() < this.query.date.endMtime.getTime() + DAY_LENGTH && (item.file.stat.mtime < this.query.date.startMtime.getTime() || item.file.stat.mtime > this.query.date.endMtime.getTime() + DAY_LENGTH)) return false;
    if (mediaTypes.contains("image" /* Image */)) {
      const image = item;
      const size = await image.getCachedSize();
      if (size) {
        if (this.query.dimensions.minWidth && size.width < this.query.dimensions.minWidth) return false;
        if (this.query.dimensions.maxWidth && size.width > this.query.dimensions.maxWidth) return false;
        if (this.query.dimensions.minHeight && size.height < this.query.dimensions.minHeight) return false;
        if (this.query.dimensions.maxHeight && size.height > this.query.dimensions.maxHeight) return false;
        if (this.query.shape) {
          if (this.query.shape !== getShape(size.width, size.height)) return false;
        }
      }
      if (this.query.color) {
        let rgbToHsl2 = function(r2, g2, b2) {
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          const max = Math.max(r2, g2, b2);
          const min = Math.min(r2, g2, b2);
          const d = max - min;
          let h2 = 0;
          if (d === 0) h2 = 0;
          else if (max === r2) h2 = (g2 - b2) / d % 6;
          else if (max === g2) h2 = (b2 - r2) / d + 2;
          else if (max === b2) h2 = (r2 - g2) / d + 4;
          const l2 = (min + max) / 2;
          const s2 = d === 0 ? 0 : d / (1 - Math.abs(2 * l2 - 1));
          return [h2 * 60, s2, l2];
        };
        var rgbToHsl = rgbToHsl2;
        const color = this.query.color;
        const r = parseInt(color.substring(1, 3), 16);
        const g = parseInt(color.substring(3, 5), 16);
        const b = parseInt(color.substring(5, 7), 16);
        const hsl = rgbToHsl2(r, g, b);
        const h = hsl[0];
        const s = hsl[1];
        const l = hsl[2];
        let distance2 = 0;
        const colors = await image.getCachedColors();
        if (!colors || !Array.isArray(colors)) return false;
        if (colors.length === 0) return false;
        for (const color2 of colors) {
          const ch = color2.h * 360;
          const cs = color2.s;
          const cl = color2.l;
          const hDiff = Math.min(Math.abs(ch - h), Math.abs(ch - h + 360));
          const sDiff = Math.abs(cs - s);
          const lDiff = Math.abs(cl - l);
          distance2 += (hDiff / 180 + sDiff + lDiff) * color2.area;
          if (distance2 > 0.5) return false;
        }
      }
    }
    if (this.query.name.length > 0) {
      if (!item.file.basename.toLowerCase().includes(this.query.name.toLowerCase())) return false;
    }
    let foundIncludeFolder = false;
    for (const [folder, include] of this.sortedFolders) {
      if (item.file.path.startsWith(folder)) {
        if (!include) return false;
        else foundIncludeFolder = true;
        break;
      }
    }
    if (this.anyFolderInclude && !foundIncludeFolder) return false;
    let foundIncludeTag = false;
    tagsLoop: for (const mTag of item.sidecar.getTags()) {
      for (const [tag, include] of this.sortedTags) {
        if (mTag.startsWith(tag)) {
          if (!include) return false;
          else foundIncludeTag = true;
          continue tagsLoop;
        }
      }
    }
    if (this.anyTagInclude && !foundIncludeTag) return false;
    return true;
  }
  /**
   * Filters all mediafiles from the cache and returns the ones
   * that fit the query. Will wait for the cache to be ready
   * @returns All MediaFiles from the cache that fit the query
   */
  async getItems() {
    await this.cache.awaitReady();
    this.files = [...this.cache.files];
    this.orderFiles();
    const found = [];
    while (this.currentIndex < this.cache.files.length - 1) {
      this.currentIndex++;
      const item = this.files[this.currentIndex];
      if (await this.testFile(item)) {
        found.push(item);
        this.totalFound++;
      }
    }
    return found;
  }
  /**
   * Finds the types of files that the user could be querying based on the
   * parameters given in the query
   * @returns The possible types of files that can be queried with the current
   * query parameters
   */
  determineTypes() {
    if (this.query.dimensions && (this.query.dimensions.maxHeight !== null || this.query.dimensions.maxWidth !== null || this.query.dimensions.minHeight !== null || this.query.dimensions.minWidth !== null) || this.query.shape !== null || this.query.color !== null) {
      return ["image" /* Image */];
    }
    return [];
  }
};
_Query.defaultQuery = {
  name: "",
  folders: {
    included: [],
    excluded: []
  },
  tags: {
    included: [],
    excluded: []
  },
  fileTypes: {
    included: [],
    excluded: []
  },
  color: null,
  shape: null,
  dimensions: {
    minWidth: null,
    maxWidth: null,
    minHeight: null,
    maxHeight: null
  },
  date: {
    startCtime: null,
    endCtime: null,
    startMtime: null,
    endMtime: null
  },
  orderBy: "name" /* name */,
  orderIncreasing: true
};
var Query = _Query;

// src/components/Gallery.svelte
var import_obsidian5 = require("obsidian");

// src/stores/appStore.ts
var app = writable();
var appStore_default = { app };

// src/components/Gallery.svelte
var import_masonry_layout = __toESM(require_masonry());
var import_imagesloaded = __toESM(require_imagesloaded());

// src/stores/activeStore.ts
var file = writable();
var activeStore_default = { file };

// src/components/MediaFileEmbed.svelte
function create_fragment(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      toggle_class(
        div,
        "MC-embeded",
        /*embedCreator*/
        ctx[0]
      );
      toggle_class(div, "MC-no-embed", !/*embedCreator*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*embedCreator*/
      1) {
        toggle_class(
          div,
          "MC-embeded",
          /*embedCreator*/
          ctx2[0]
        );
      }
      if (dirty & /*embedCreator*/
      1) {
        toggle_class(div, "MC-no-embed", !/*embedCreator*/
        ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[4](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let app2 = get_store_value(appStore_default.app);
  let { file: file2 } = $$props;
  let { recomputeDimensions = () => {
  } } = $$props;
  let embedCreator = app2.embedRegistry.getEmbedCreator(file2);
  let containerEl;
  let embed;
  function setEmbed() {
    $$invalidate(0, embedCreator = app2.embedRegistry.getEmbedCreator(file2));
    if (embedCreator && containerEl) {
      $$invalidate(1, containerEl.innerHTML = "", containerEl);
      let embedElement = containerEl.createDiv();
      embed = embedCreator({ app: app2, containerEl: embedElement }, file2, file2.path);
      embed.loadFile();
    } else if (!embedCreator && containerEl) {
      $$invalidate(1, containerEl.innerHTML = file2.path, containerEl);
    }
  }
  onMount(() => {
    setEmbed();
    const videoEl = containerEl.getElementsByTagName("video")[0];
    if (videoEl) {
      videoEl.addEventListener("loadedmetadata", () => recomputeDimensions(), false);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(1, containerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2) $$invalidate(2, file2 = $$props2.file);
    if ("recomputeDimensions" in $$props2) $$invalidate(3, recomputeDimensions = $$props2.recomputeDimensions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*file*/
    4) {
      $: if (file2) setEmbed();
    }
  };
  return [embedCreator, containerEl, file2, recomputeDimensions, div_binding];
}
var MediaFileEmbed = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { file: 2, recomputeDimensions: 3 });
  }
};
var MediaFileEmbed_default = MediaFileEmbed;

// src/components/Gallery.svelte
var import_obsidian6 = require("obsidian");

// src/components/search/Popup.svelte
var import_obsidian2 = require("obsidian");
function create_fragment2(ctx) {
  let button1;
  let span0;
  let t0;
  let t1;
  let div0;
  let button0;
  let span1;
  let div0_hidden_value;
  let button1_style_value;
  let t2;
  let div1;
  let div1_hidden_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  return {
    c() {
      button1 = element("button");
      span0 = element("span");
      t0 = text(
        /*text*/
        ctx[2]
      );
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      span1 = element("span");
      t2 = space();
      div1 = element("div");
      if (default_slot) default_slot.c();
      attr(span0, "class", "MC-icon-container");
      attr(span1, "class", "MC-icon-container");
      attr(button0, "class", "MC-reset-button");
      attr(button0, "aria-label", "Reset");
      div0.hidden = div0_hidden_value = !/*active*/
      ctx[1];
      attr(button1, "class", "MC-popup-trigger");
      attr(button1, "style", button1_style_value = /*activeColor*/
      ctx[3] && /*active*/
      ctx[1] ? `background-color: ${/*activeColor*/
      ctx[3]};` : "");
      toggle_class(
        button1,
        "MC-popup-active",
        /*active*/
        ctx[1]
      );
      attr(div1, "class", "MC-popup");
      set_style(
        div1,
        "top",
        /*popupTop*/
        ctx[8] + "px"
      );
      set_style(
        div1,
        "left",
        /*popupLeft*/
        ctx[9] + "px"
      );
      div1.hidden = div1_hidden_value = !/*show*/
      ctx[0];
    },
    m(target, anchor) {
      insert(target, button1, anchor);
      append(button1, span0);
      ctx[16](span0);
      append(button1, t0);
      append(button1, t1);
      append(button1, div0);
      append(div0, button0);
      append(button0, span1);
      ctx[17](span1);
      ctx[18](button1);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[19](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleResetClick*/
            ctx[10]
          ),
          listen(
            button1,
            "click",
            /*openPopup*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*text*/
      4) set_data(
        t0,
        /*text*/
        ctx2[2]
      );
      if (!current || dirty & /*active*/
      2 && div0_hidden_value !== (div0_hidden_value = !/*active*/
      ctx2[1])) {
        div0.hidden = div0_hidden_value;
      }
      if (!current || dirty & /*activeColor, active*/
      10 && button1_style_value !== (button1_style_value = /*activeColor*/
      ctx2[3] && /*active*/
      ctx2[1] ? `background-color: ${/*activeColor*/
      ctx2[3]};` : "")) {
        attr(button1, "style", button1_style_value);
      }
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          button1,
          "MC-popup-active",
          /*active*/
          ctx2[1]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*popupTop*/
      256) {
        set_style(
          div1,
          "top",
          /*popupTop*/
          ctx2[8] + "px"
        );
      }
      if (!current || dirty & /*popupLeft*/
      512) {
        set_style(
          div1,
          "left",
          /*popupLeft*/
          ctx2[9] + "px"
        );
      }
      if (!current || dirty & /*show*/
      1 && div1_hidden_value !== (div1_hidden_value = !/*show*/
      ctx2[0])) {
        div1.hidden = div1_hidden_value;
      }
    },
    i(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button1);
        detach(t2);
        detach(div1);
      }
      ctx[16](null);
      ctx[17](null);
      ctx[18](null);
      if (default_slot) default_slot.d(detaching);
      ctx[19](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { show = false } = $$props;
  let { active: active2 = false } = $$props;
  let { icon = "info" } = $$props;
  let { text: text2 = "button" } = $$props;
  let { activeColor = null } = $$props;
  let { reset = () => {
  } } = $$props;
  let iconElement;
  let buttonElement;
  let popupElement;
  let resetIconElement;
  let popupTop = 0;
  let popupLeft = 0;
  function handleClickOutside(event) {
    if (show && !buttonElement.contains(event.target) && !popupElement.contains(event.target)) {
      $$invalidate(0, show = false);
    }
  }
  function handleKeydown(event) {
    if (show && event.key === "Escape") {
      $$invalidate(0, show = false);
    }
  }
  function handleResetClick(event) {
    event.stopPropagation();
    reset();
  }
  onMount(() => {
    (0, import_obsidian2.setIcon)(iconElement, icon);
    (0, import_obsidian2.setIcon)(resetIconElement, "x");
    window.addEventListener("click", handleClickOutside);
    window.addEventListener("keydown", handleKeydown);
  });
  onDestroy(() => {
    window.removeEventListener("click", handleClickOutside);
    window.removeEventListener("keydown", handleKeydown);
  });
  function openPopup() {
    $$invalidate(0, show = true);
    positionPopup();
    setTimeout(positionPopup, 0);
  }
  function positionPopup() {
    if (!popupElement || !buttonElement) return;
    const containerPadding = 5;
    const buttonRect = buttonElement.getBoundingClientRect();
    const popupRect = popupElement.getBoundingClientRect();
    const parentElement = buttonElement.offsetParent || buttonElement.parentElement;
    const parentRect = parentElement.getBoundingClientRect();
    let top = buttonRect.bottom - parentRect.top;
    let left = buttonRect.left - parentRect.left;
    const containerWidth = parentElement instanceof HTMLElement ? parentElement.clientWidth : window.innerWidth;
    if (left + popupRect.width > containerWidth - containerPadding) {
      if (buttonRect.right + left > containerWidth - containerPadding) {
        left = containerWidth - containerPadding - popupRect.width;
      } else {
        left = buttonRect.right - parentRect.left - popupRect.width;
      }
    }
    $$invalidate(8, popupTop = top);
    $$invalidate(9, popupLeft = left);
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconElement = $$value;
      $$invalidate(4, iconElement);
    });
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      resetIconElement = $$value;
      $$invalidate(7, resetIconElement);
    });
  }
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonElement = $$value;
      $$invalidate(5, buttonElement);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popupElement = $$value;
      $$invalidate(6, popupElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("show" in $$props2) $$invalidate(0, show = $$props2.show);
    if ("active" in $$props2) $$invalidate(1, active2 = $$props2.active);
    if ("icon" in $$props2) $$invalidate(12, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    if ("activeColor" in $$props2) $$invalidate(3, activeColor = $$props2.activeColor);
    if ("reset" in $$props2) $$invalidate(13, reset = $$props2.reset);
    if ("$$scope" in $$props2) $$invalidate(14, $$scope = $$props2.$$scope);
  };
  return [
    show,
    active2,
    text2,
    activeColor,
    iconElement,
    buttonElement,
    popupElement,
    resetIconElement,
    popupTop,
    popupLeft,
    handleResetClick,
    openPopup,
    icon,
    reset,
    $$scope,
    slots,
    span0_binding,
    span1_binding,
    button1_binding,
    div1_binding
  ];
}
var Popup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      show: 0,
      active: 1,
      icon: 12,
      text: 2,
      activeColor: 3,
      reset: 13
    });
  }
};
var Popup_default = Popup;

// src/components/search/IncludeSelect.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i][0];
  child_ctx[19] = list[i][1];
  return child_ctx;
}
function create_each_block(ctx) {
  let div1;
  let span0;
  let t0_value = (
    /*option*/
    ctx[18] + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*count*/
    ctx[19] + ""
  );
  let t2;
  let t3;
  let div0;
  let button0;
  let t5;
  let button1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*option*/
        ctx[18]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[16](
        /*option*/
        ctx[18]
      )
    );
  }
  return {
    c() {
      div1 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "+";
      t5 = space();
      button1 = element("button");
      button1.textContent = "-";
      attr(span0, "class", "MC-include-option-text");
      attr(span1, "class", "MC-include-option-count");
      attr(button0, "class", "MC-include-button");
      attr(button0, "aria-label", "Include");
      toggle_class(
        button0,
        "MC-include-active",
        /*included*/
        ctx[0].includes(
          /*option*/
          ctx[18]
        )
      );
      attr(button1, "class", "MC-include-button");
      attr(button1, "aria-label", "Exclude");
      toggle_class(
        button1,
        "MC-include-active",
        /*excluded*/
        ctx[1].includes(
          /*option*/
          ctx[18]
        )
      );
      attr(div0, "class", "MC-include-option-buttons");
      attr(div1, "class", "MC-include-option-row");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span0);
      append(span0, t0);
      append(div1, t1);
      append(div1, span1);
      append(span1, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, button0);
      append(div0, t5);
      append(div0, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler),
          listen(button1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*filteredOptions*/
      128 && t0_value !== (t0_value = /*option*/
      ctx[18] + "")) set_data(t0, t0_value);
      if (dirty & /*filteredOptions*/
      128 && t2_value !== (t2_value = /*count*/
      ctx[19] + "")) set_data(t2, t2_value);
      if (dirty & /*included, filteredOptions*/
      129) {
        toggle_class(
          button0,
          "MC-include-active",
          /*included*/
          ctx[0].includes(
            /*option*/
            ctx[18]
          )
        );
      }
      if (dirty & /*excluded, filteredOptions*/
      130) {
        toggle_class(
          button1,
          "MC-include-active",
          /*excluded*/
          ctx[1].includes(
            /*option*/
            ctx[18]
          )
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No results found";
      attr(div, "class", "MC-include-no-results");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot(ctx) {
  let div2;
  let div0;
  let input;
  let t0;
  let div1;
  let t1;
  let div2_style_value;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*filteredOptions*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block = (
    /*filteredOptions*/
    ctx[7].length === 0 && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block) if_block.c();
      attr(input, "type", "text");
      attr(input, "placeholder", "Search...");
      attr(input, "class", "MC-include-search");
      attr(div1, "class", "MC-include-options-list");
      attr(div2, "class", "MC-include-container");
      attr(div2, "style", div2_style_value = /*containerWidth*/
      ctx[5] ? `min-width: ${/*containerWidth*/
      ctx[5]}px` : "");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, input);
      set_input_value(
        input,
        /*searchTerm*/
        ctx[4]
      );
      append(div2, t0);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div1, t1);
      if (if_block) if_block.m(div1, null);
      ctx[17](div2);
      if (!mounted) {
        dispose = listen(
          input,
          "input",
          /*input_input_handler*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*searchTerm*/
      16 && input.value !== /*searchTerm*/
      ctx2[4]) {
        set_input_value(
          input,
          /*searchTerm*/
          ctx2[4]
        );
      }
      if (dirty & /*excluded, filteredOptions, toggleExclude, included, toggleInclude*/
      1667) {
        each_value = ensure_array_like(
          /*filteredOptions*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*filteredOptions*/
        ctx2[7].length === 0
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*containerWidth*/
      32 && div2_style_value !== (div2_style_value = /*containerWidth*/
      ctx2[5] ? `min-width: ${/*containerWidth*/
      ctx2[5]}px` : "")) {
        attr(div2, "style", div2_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d();
      ctx[17](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let popup;
  let current;
  popup = new Popup_default({
    props: {
      icon: (
        /*icon*/
        ctx[2]
      ),
      text: (
        /*text*/
        ctx[3]
      ),
      active: (
        /*active*/
        ctx[8]
      ),
      reset: (
        /*reset*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popup_changes = {};
      if (dirty & /*icon*/
      4) popup_changes.icon = /*icon*/
      ctx2[2];
      if (dirty & /*text*/
      8) popup_changes.text = /*text*/
      ctx2[3];
      if (dirty & /*active*/
      256) popup_changes.active = /*active*/
      ctx2[8];
      if (dirty & /*$$scope, containerWidth, container, filteredOptions, excluded, included, searchTerm*/
      4194547) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let filteredOptions;
  let { options = [] } = $$props;
  let { included = [] } = $$props;
  let { excluded = [] } = $$props;
  let { icon = "info" } = $$props;
  let { text: text2 = "include" } = $$props;
  let { updated = () => {
  } } = $$props;
  let active2;
  let searchTerm = "";
  let containerWidth = 0;
  let container;
  function toggleInclude(option) {
    if (included.includes(option)) {
      $$invalidate(0, included = included.filter((o) => o !== option));
    } else {
      $$invalidate(0, included = [...included, option]);
      $$invalidate(1, excluded = excluded.filter((o) => o !== option));
    }
    updated();
  }
  function toggleExclude(option) {
    if (excluded.includes(option)) {
      $$invalidate(1, excluded = excluded.filter((o) => o !== option));
    } else {
      $$invalidate(1, excluded = [...excluded, option]);
      $$invalidate(0, included = included.filter((o) => o !== option));
    }
    updated();
  }
  function reset() {
    $$invalidate(0, included = []);
    $$invalidate(1, excluded = []);
    updated();
  }
  function input_input_handler() {
    searchTerm = this.value;
    $$invalidate(4, searchTerm);
  }
  const click_handler = (option) => toggleInclude(option);
  const click_handler_1 = (option) => toggleExclude(option);
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(6, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2) $$invalidate(12, options = $$props2.options);
    if ("included" in $$props2) $$invalidate(0, included = $$props2.included);
    if ("excluded" in $$props2) $$invalidate(1, excluded = $$props2.excluded);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(3, text2 = $$props2.text);
    if ("updated" in $$props2) $$invalidate(13, updated = $$props2.updated);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*included, excluded*/
    3) {
      $: $$invalidate(8, active2 = included.length > 0 || excluded.length > 0);
    }
    if ($$self.$$.dirty & /*searchTerm, options*/
    4112) {
      $: $$invalidate(7, filteredOptions = searchTerm ? options.filter(([opt]) => opt.toLowerCase().includes(searchTerm.toLowerCase())) : options);
    }
    if ($$self.$$.dirty & /*filteredOptions, container, containerWidth*/
    224) {
      $: if (filteredOptions && filteredOptions.length > 0) {
        setTimeout(
          () => {
            if (container && container.clientWidth > containerWidth) $$invalidate(5, containerWidth = container.clientWidth);
          },
          0
        );
      }
    }
  };
  return [
    included,
    excluded,
    icon,
    text2,
    searchTerm,
    containerWidth,
    container,
    filteredOptions,
    active2,
    toggleInclude,
    toggleExclude,
    reset,
    options,
    updated,
    input_input_handler,
    click_handler,
    click_handler_1,
    div2_binding
  ];
}
var IncludeSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      options: 12,
      included: 0,
      excluded: 1,
      icon: 2,
      text: 3,
      updated: 13
    });
  }
};
var IncludeSelect_default = IncludeSelect;

// src/components/search/ColourPicker.svelte
function create_default_slot2(ctx) {
  let div8;
  let div4;
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let div2_style_value;
  let div3_style_value;
  let t2;
  let div7;
  let div6;
  let div5;
  let div5_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      div8 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div7 = element("div");
      div6 = element("div");
      div5 = element("div");
      attr(div0, "class", "white-gradient");
      attr(div1, "class", "black-gradient");
      attr(div2, "class", "color-indicator");
      attr(div2, "style", div2_style_value = `left: ${/*saturation*/
      ctx[4] * 100}%; top: ${100 - /*value*/
      ctx[5] * 100}%`);
      attr(div3, "class", "color-square");
      attr(div3, "style", div3_style_value = `--hue: ${/*hue*/
      ctx[3]}`);
      attr(div4, "class", "color-square-wrapper");
      attr(div5, "class", "hue-indicator");
      attr(div5, "style", div5_style_value = `left: ${/*hue*/
      ctx[3] / 360 * 100}%`);
      attr(div6, "class", "hue-slider");
      attr(div7, "class", "hue-slider-wrapper");
      attr(div8, "class", "color-picker-container");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div4);
      append(div4, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      ctx[13](div3);
      append(div8, t2);
      append(div8, div7);
      append(div7, div6);
      append(div6, div5);
      ctx[14](div6);
      if (!mounted) {
        dispose = [
          listen(div3, "mousedown", prevent_default(
            /*handleSquareDown*/
            ctx[10]
          )),
          listen(div6, "mousedown", prevent_default(
            /*handleHueDown*/
            ctx[11]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*saturation, value*/
      48 && div2_style_value !== (div2_style_value = `left: ${/*saturation*/
      ctx2[4] * 100}%; top: ${100 - /*value*/
      ctx2[5] * 100}%`)) {
        attr(div2, "style", div2_style_value);
      }
      if (dirty & /*hue*/
      8 && div3_style_value !== (div3_style_value = `--hue: ${/*hue*/
      ctx2[3]}`)) {
        attr(div3, "style", div3_style_value);
      }
      if (dirty & /*hue*/
      8 && div5_style_value !== (div5_style_value = `left: ${/*hue*/
      ctx2[3] / 360 * 100}%`)) {
        attr(div5, "style", div5_style_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div8);
      }
      ctx[13](null);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment4(ctx) {
  let popup;
  let current;
  popup = new Popup_default({
    props: {
      icon: (
        /*icon*/
        ctx[1]
      ),
      text: (
        /*text*/
        ctx[2]
      ),
      active: (
        /*active*/
        ctx[8]
      ),
      reset: (
        /*reset*/
        ctx[9]
      ),
      activeColor: (
        /*color*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popup_changes = {};
      if (dirty & /*icon*/
      2) popup_changes.icon = /*icon*/
      ctx2[1];
      if (dirty & /*text*/
      4) popup_changes.text = /*text*/
      ctx2[2];
      if (dirty & /*active*/
      256) popup_changes.active = /*active*/
      ctx2[8];
      if (dirty & /*color*/
      1) popup_changes.activeColor = /*color*/
      ctx2[0];
      if (dirty & /*$$scope, hueSlider, hue, colorSquare, saturation, value*/
      4194552) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function hsv2rgb(h, s, v) {
  let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  let r = Math.round(f(5) * 255);
  let g = Math.round(f(3) * 255);
  let b = Math.round(f(1) * 255);
  function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }
  return `#${componentToHex(r)}${componentToHex(g)}${componentToHex(b)}`;
}
function instance4($$self, $$props, $$invalidate) {
  let active2;
  let { icon = "palette" } = $$props;
  let { text: text2 = "Color" } = $$props;
  let { color = null } = $$props;
  let { updated = () => {
  } } = $$props;
  function reset() {
    $$invalidate(0, color = null);
    updated();
  }
  let hue = 0;
  let saturation = 1;
  let value = 1;
  let colorSquare;
  let hueSlider;
  let isDraggingSquare = false;
  let isDraggingHue = false;
  onMount(() => {
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  });
  onDestroy(() => {
    window.removeEventListener("mousemove", handleMouseMove);
    window.removeEventListener("mouseup", handleMouseUp);
  });
  function handleSquareDown(event) {
    isDraggingSquare = true;
    updateColorFromSquare(event);
  }
  function handleHueDown(event) {
    isDraggingHue = true;
    updateHueFromSlider(event);
  }
  function handleMouseMove(event) {
    if (isDraggingSquare) {
      updateColorFromSquare(event);
    } else if (isDraggingHue) {
      updateHueFromSlider(event);
    }
  }
  function handleMouseUp() {
    isDraggingSquare = false;
    isDraggingHue = false;
  }
  function updateColorFromSquare(event) {
    if (!colorSquare) return;
    const rect = colorSquare.getBoundingClientRect();
    $$invalidate(4, saturation = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width)));
    $$invalidate(5, value = 1 - Math.max(0, Math.min(1, (event.clientY - rect.top) / rect.height)));
    updateColor();
  }
  function updateHueFromSlider(event) {
    if (!hueSlider) return;
    const rect = hueSlider.getBoundingClientRect();
    const x = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
    $$invalidate(3, hue = Math.round(x * 360));
    updateColor();
  }
  function updateColor() {
    $$invalidate(0, color = hsv2rgb(hue, saturation, value));
    updated();
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      colorSquare = $$value;
      $$invalidate(6, colorSquare);
    });
  }
  function div6_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      hueSlider = $$value;
      $$invalidate(7, hueSlider);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    if ("color" in $$props2) $$invalidate(0, color = $$props2.color);
    if ("updated" in $$props2) $$invalidate(12, updated = $$props2.updated);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color*/
    1) {
      $: $$invalidate(8, active2 = color !== null);
    }
  };
  return [
    color,
    icon,
    text2,
    hue,
    saturation,
    value,
    colorSquare,
    hueSlider,
    active2,
    reset,
    handleSquareDown,
    handleHueDown,
    updated,
    div3_binding,
    div6_binding
  ];
}
var ColourPicker = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { icon: 1, text: 2, color: 0, updated: 12 });
  }
};
var ColourPicker_default = ColourPicker;

// src/components/search/Resolution.svelte
var import_obsidian3 = require("obsidian");
function create_default_slot3(ctx) {
  let div8;
  let div0;
  let button0;
  let t0;
  let button1;
  let t1;
  let button2;
  let t2;
  let button3;
  let t3;
  let div7;
  let div3;
  let div1;
  let label0;
  let t5;
  let input0;
  let t6;
  let div2;
  let label1;
  let t8;
  let input1;
  let t9;
  let div6;
  let div4;
  let label2;
  let t11;
  let input2;
  let t12;
  let div5;
  let label3;
  let t14;
  let input3;
  let mounted;
  let dispose;
  return {
    c() {
      div8 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = ``;
      t0 = space();
      button1 = element("button");
      button1.innerHTML = ``;
      t1 = space();
      button2 = element("button");
      button2.innerHTML = ``;
      t2 = space();
      button3 = element("button");
      button3.innerHTML = ``;
      t3 = space();
      div7 = element("div");
      div3 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Min Height";
      t5 = space();
      input0 = element("input");
      t6 = space();
      div2 = element("div");
      label1 = element("label");
      label1.textContent = "Max Height";
      t8 = space();
      input1 = element("input");
      t9 = space();
      div6 = element("div");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = "Min Width";
      t11 = space();
      input2 = element("input");
      t12 = space();
      div5 = element("div");
      label3 = element("label");
      label3.textContent = "Max Width";
      t14 = space();
      input3 = element("input");
      attr(button0, "title", "Square");
      toggle_class(
        button0,
        "MC-resolution-selected",
        /*shape*/
        ctx[0] === "square" /* Square */
      );
      attr(button1, "title", "Horizontal");
      toggle_class(
        button1,
        "MC-resolution-selected",
        /*shape*/
        ctx[0] === "horizontal" /* Horizontal */
      );
      attr(button2, "title", "Vertical");
      toggle_class(
        button2,
        "MC-resolution-selected",
        /*shape*/
        ctx[0] === "vertical" /* Vertical */
      );
      attr(button3, "title", "Remove shape filter");
      toggle_class(
        button3,
        "MC-resolution-selected",
        /*shape*/
        ctx[0] === null
      );
      attr(div0, "class", "MC-shape-buttons");
      attr(label0, "for", "minY");
      attr(input0, "id", "minY");
      attr(input0, "type", "number");
      attr(input0, "min", "0");
      attr(input0, "step", "any");
      attr(input0, "placeholder", "Min");
      attr(div1, "class", "MC-input-group");
      attr(label1, "for", "maxY");
      attr(input1, "id", "maxY");
      attr(input1, "type", "number");
      attr(input1, "min", "0");
      attr(input1, "step", "any");
      attr(input1, "placeholder", "Max");
      attr(div2, "class", "MC-input-group");
      attr(div3, "class", "MC-dimension-row");
      attr(label2, "for", "minX");
      attr(input2, "id", "minX");
      attr(input2, "type", "number");
      attr(input2, "min", "0");
      attr(input2, "step", "any");
      attr(input2, "placeholder", "Min");
      attr(div4, "class", "MC-input-group");
      attr(label3, "for", "maxX");
      attr(input3, "id", "maxX");
      attr(input3, "type", "number");
      attr(input3, "min", "0");
      attr(input3, "step", "any");
      attr(input3, "placeholder", "Max");
      attr(div5, "class", "MC-input-group");
      attr(div6, "class", "MC-dimension-row");
      attr(div7, "class", "MC-dimension-inputs");
      attr(div8, "class", "MC-resolution-container");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div0);
      append(div0, button0);
      ctx[23](button0);
      append(div0, t0);
      append(div0, button1);
      ctx[25](button1);
      append(div0, t1);
      append(div0, button2);
      ctx[27](button2);
      append(div0, t2);
      append(div0, button3);
      ctx[29](button3);
      append(div8, t3);
      append(div8, div7);
      append(div7, div3);
      append(div3, div1);
      append(div1, label0);
      append(div1, t5);
      append(div1, input0);
      set_input_value(
        input0,
        /*minYInput*/
        ctx[3]
      );
      append(div3, t6);
      append(div3, div2);
      append(div2, label1);
      append(div2, t8);
      append(div2, input1);
      set_input_value(
        input1,
        /*maxYInput*/
        ctx[4]
      );
      append(div7, t9);
      append(div7, div6);
      append(div6, div4);
      append(div4, label2);
      append(div4, t11);
      append(div4, input2);
      set_input_value(
        input2,
        /*minXInput*/
        ctx[5]
      );
      append(div6, t12);
      append(div6, div5);
      append(div5, label3);
      append(div5, t14);
      append(div5, input3);
      set_input_value(
        input3,
        /*maxXInput*/
        ctx[6]
      );
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[24]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[26]
          ),
          listen(
            button2,
            "click",
            /*click_handler_2*/
            ctx[28]
          ),
          listen(
            button3,
            "click",
            /*click_handler_3*/
            ctx[30]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[31]
          ),
          listen(
            input0,
            "keyup",
            /*updateMinY*/
            ctx[14]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[32]
          ),
          listen(
            input1,
            "keyup",
            /*updateMaxY*/
            ctx[15]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[33]
          ),
          listen(
            input2,
            "keyup",
            /*updateMinX*/
            ctx[16]
          ),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[34]
          ),
          listen(
            input3,
            "keyup",
            /*updateMaxX*/
            ctx[17]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*shape*/
      1) {
        toggle_class(
          button0,
          "MC-resolution-selected",
          /*shape*/
          ctx2[0] === "square" /* Square */
        );
      }
      if (dirty[0] & /*shape*/
      1) {
        toggle_class(
          button1,
          "MC-resolution-selected",
          /*shape*/
          ctx2[0] === "horizontal" /* Horizontal */
        );
      }
      if (dirty[0] & /*shape*/
      1) {
        toggle_class(
          button2,
          "MC-resolution-selected",
          /*shape*/
          ctx2[0] === "vertical" /* Vertical */
        );
      }
      if (dirty[0] & /*shape*/
      1) {
        toggle_class(
          button3,
          "MC-resolution-selected",
          /*shape*/
          ctx2[0] === null
        );
      }
      if (dirty[0] & /*minYInput*/
      8 && to_number(input0.value) !== /*minYInput*/
      ctx2[3]) {
        set_input_value(
          input0,
          /*minYInput*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*maxYInput*/
      16 && to_number(input1.value) !== /*maxYInput*/
      ctx2[4]) {
        set_input_value(
          input1,
          /*maxYInput*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*minXInput*/
      32 && to_number(input2.value) !== /*minXInput*/
      ctx2[5]) {
        set_input_value(
          input2,
          /*minXInput*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*maxXInput*/
      64 && to_number(input3.value) !== /*maxXInput*/
      ctx2[6]) {
        set_input_value(
          input3,
          /*maxXInput*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div8);
      }
      ctx[23](null);
      ctx[25](null);
      ctx[27](null);
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment5(ctx) {
  let popup;
  let current;
  popup = new Popup_default({
    props: {
      icon: (
        /*icon*/
        ctx[1]
      ),
      text: (
        /*text*/
        ctx[2]
      ),
      active: (
        /*active*/
        ctx[11]
      ),
      reset: (
        /*reset*/
        ctx[12]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popup_changes = {};
      if (dirty[0] & /*icon*/
      2) popup_changes.icon = /*icon*/
      ctx2[1];
      if (dirty[0] & /*text*/
      4) popup_changes.text = /*text*/
      ctx2[2];
      if (dirty[0] & /*active*/
      2048) popup_changes.active = /*active*/
      ctx2[11];
      if (dirty[0] & /*maxXInput, minXInput, maxYInput, minYInput, resetButton, shape, verticalButton, horizontalButton, squareButton*/
      2041 | dirty[1] & /*$$scope*/
      16) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function handleInput(value, setter) {
  let num = 0;
  if (typeof value == "string") {
    if (value.trim() === "") {
      setter(null);
      return;
    } else {
      num = parseInt(value);
    }
  } else {
    num = value;
  }
  if (!isNaN(num) && num >= 0) {
    setter(num);
  }
}
function instance5($$self, $$props, $$invalidate) {
  let active2;
  let { icon = "proportions" } = $$props;
  let { text: text2 = "Size" } = $$props;
  let { updated = () => {
  } } = $$props;
  let { shape = null } = $$props;
  let { minY = null } = $$props;
  let { maxY = null } = $$props;
  let { minX = null } = $$props;
  let { maxX = null } = $$props;
  let minYInput = minY !== null ? minY.toString() : "";
  let maxYInput = maxY !== null ? maxY.toString() : "";
  let minXInput = minX !== null ? minX.toString() : "";
  let maxXInput = maxX !== null ? maxX.toString() : "";
  let squareButton;
  let horizontalButton;
  let verticalButton;
  let resetButton;
  function reset() {
    $$invalidate(0, shape = null);
    $$invalidate(18, minY = null);
    $$invalidate(19, maxY = null);
    $$invalidate(20, minX = null);
    $$invalidate(21, maxX = null);
    $$invalidate(3, minYInput = "");
    $$invalidate(4, maxYInput = "");
    $$invalidate(5, minXInput = "");
    $$invalidate(6, maxXInput = "");
    updated();
  }
  function setShape(newShape) {
    $$invalidate(0, shape = newShape);
    updated();
  }
  function updateMinY() {
    handleInput(minYInput, (val) => {
      $$invalidate(18, minY = val);
      updated();
    });
  }
  function updateMaxY() {
    handleInput(maxYInput, (val) => {
      $$invalidate(19, maxY = val);
      updated();
    });
  }
  function updateMinX() {
    handleInput(minXInput, (val) => {
      $$invalidate(20, minX = val);
      updated();
    });
  }
  function updateMaxX() {
    handleInput(maxXInput, (val) => {
      $$invalidate(21, maxX = val);
      updated();
    });
  }
  onMount(() => {
    (0, import_obsidian3.setIcon)(squareButton, "square");
    (0, import_obsidian3.setIcon)(horizontalButton, "rectangle-horizontal");
    (0, import_obsidian3.setIcon)(verticalButton, "rectangle-vertical");
    (0, import_obsidian3.setIcon)(resetButton, "x");
  });
  function button0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      squareButton = $$value;
      $$invalidate(7, squareButton);
    });
  }
  const click_handler = () => setShape("square" /* Square */);
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      horizontalButton = $$value;
      $$invalidate(8, horizontalButton);
    });
  }
  const click_handler_1 = () => setShape("horizontal" /* Horizontal */);
  function button2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      verticalButton = $$value;
      $$invalidate(9, verticalButton);
    });
  }
  const click_handler_2 = () => setShape("vertical" /* Vertical */);
  function button3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      resetButton = $$value;
      $$invalidate(10, resetButton);
    });
  }
  const click_handler_3 = () => setShape(null);
  function input0_input_handler() {
    minYInput = to_number(this.value);
    $$invalidate(3, minYInput);
  }
  function input1_input_handler() {
    maxYInput = to_number(this.value);
    $$invalidate(4, maxYInput);
  }
  function input2_input_handler() {
    minXInput = to_number(this.value);
    $$invalidate(5, minXInput);
  }
  function input3_input_handler() {
    maxXInput = to_number(this.value);
    $$invalidate(6, maxXInput);
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    if ("updated" in $$props2) $$invalidate(22, updated = $$props2.updated);
    if ("shape" in $$props2) $$invalidate(0, shape = $$props2.shape);
    if ("minY" in $$props2) $$invalidate(18, minY = $$props2.minY);
    if ("maxY" in $$props2) $$invalidate(19, maxY = $$props2.maxY);
    if ("minX" in $$props2) $$invalidate(20, minX = $$props2.minX);
    if ("maxX" in $$props2) $$invalidate(21, maxX = $$props2.maxX);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*shape, minY, maxY, minX, maxX*/
    3932161) {
      $: $$invalidate(11, active2 = shape != null || minY != null || maxY != null || minX != null || maxX != null);
    }
  };
  return [
    shape,
    icon,
    text2,
    minYInput,
    maxYInput,
    minXInput,
    maxXInput,
    squareButton,
    horizontalButton,
    verticalButton,
    resetButton,
    active2,
    reset,
    setShape,
    updateMinY,
    updateMaxY,
    updateMinX,
    updateMaxX,
    minY,
    maxY,
    minX,
    maxX,
    updated,
    button0_binding,
    click_handler,
    button1_binding,
    click_handler_1,
    button2_binding,
    click_handler_2,
    button3_binding,
    click_handler_3,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler
  ];
}
var Resolution = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        icon: 1,
        text: 2,
        updated: 22,
        shape: 0,
        minY: 18,
        maxY: 19,
        minX: 20,
        maxX: 21
      },
      null,
      [-1, -1]
    );
  }
};
var Resolution_default = Resolution;

// src/components/search/Order.svelte
var import_obsidian4 = require("obsidian");
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let option_1;
  let t_value = (
    /*option*/
    ctx[0].replace(/([A-Z])/g, " $1").toLowerCase().replace(/^./, func) + ""
  );
  let t;
  let option_1_value_value;
  return {
    c() {
      option_1 = element("option");
      t = text(t_value);
      option_1.__value = option_1_value_value = /*option*/
      ctx[0];
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
      append(option_1, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_default_slot4(ctx) {
  let div;
  let select;
  let t;
  let button;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(Object.values(OrderByOptions));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      button = element("button");
      attr(select, "class", "dropdown");
      if (
        /*option*/
        ctx[0] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[7].call(select)
      ));
      attr(div, "class", "MC-order-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*option*/
        ctx[0],
        true
      );
      append(div, t);
      append(div, button);
      ctx[8](button);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[7]
          ),
          listen(select, "change", function() {
            if (is_function(
              /*updated*/
              ctx[3]
            )) ctx[3].apply(this, arguments);
          }),
          listen(
            button,
            "click",
            /*swapState*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*Object*/
      0) {
        each_value = ensure_array_like(Object.values(OrderByOptions));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*option, Object*/
      1) {
        select_option(
          select,
          /*option*/
          ctx[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment6(ctx) {
  let popup;
  let current;
  popup = new Popup_default({
    props: {
      icon: (
        /*icon*/
        ctx[1]
      ),
      text: (
        /*text*/
        ctx[2]
      ),
      active,
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popup_changes = {};
      if (dirty & /*icon*/
      2) popup_changes.icon = /*icon*/
      ctx2[1];
      if (dirty & /*text*/
      4) popup_changes.text = /*text*/
      ctx2[2];
      if (dirty & /*$$scope, orderButton, option, updated*/
      4121) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
var active = false;
var func = (str) => str.toUpperCase();
function instance6($$self, $$props, $$invalidate) {
  let { icon = "arrow-down-up" } = $$props;
  let { text: text2 = "Order" } = $$props;
  let { updated = () => {
  } } = $$props;
  let { option = "random" /* random */ } = $$props;
  let { orderIncreasing = true } = $$props;
  let orderButton;
  function swapState() {
    $$invalidate(6, orderIncreasing = !orderIncreasing);
    setOrderIcon();
    updated();
  }
  function setOrderIcon() {
    if (orderIncreasing) {
      (0, import_obsidian4.setIcon)(orderButton, "move-down");
    } else {
      (0, import_obsidian4.setIcon)(orderButton, "move-up");
    }
  }
  onMount(() => {
    setOrderIcon();
  });
  function select_change_handler() {
    option = select_value(this);
    $$invalidate(0, option);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      orderButton = $$value;
      $$invalidate(4, orderButton);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(2, text2 = $$props2.text);
    if ("updated" in $$props2) $$invalidate(3, updated = $$props2.updated);
    if ("option" in $$props2) $$invalidate(0, option = $$props2.option);
    if ("orderIncreasing" in $$props2) $$invalidate(6, orderIncreasing = $$props2.orderIncreasing);
  };
  return [
    option,
    icon,
    text2,
    updated,
    orderButton,
    swapState,
    orderIncreasing,
    select_change_handler,
    button_binding
  ];
}
var Order = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      icon: 1,
      text: 2,
      updated: 3,
      option: 0,
      orderIncreasing: 6
    });
  }
};
var Order_default = Order;

// src/components/search/DateRange.svelte
function create_default_slot5(ctx) {
  let div6;
  let div2;
  let div0;
  let label0;
  let t1;
  let input0;
  let t2;
  let div1;
  let label1;
  let t4;
  let input1;
  let t5;
  let div5;
  let div3;
  let label2;
  let t7;
  let input2;
  let t8;
  let div4;
  let label3;
  let t10;
  let input3;
  let mounted;
  let dispose;
  return {
    c() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Modified: From";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "To";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div5 = element("div");
      div3 = element("div");
      label2 = element("label");
      label2.textContent = "Creation: From";
      t7 = space();
      input2 = element("input");
      t8 = space();
      div4 = element("div");
      label3 = element("label");
      label3.textContent = "To";
      t10 = space();
      input3 = element("input");
      attr(label0, "for", "smtime");
      attr(input0, "id", "smtime");
      attr(input0, "type", "date");
      attr(div0, "class", "MC-input-group");
      attr(label1, "for", "emtime");
      attr(input1, "id", "emtime");
      attr(input1, "type", "date");
      attr(div1, "class", "MC-input-group");
      attr(div2, "class", "MC-date-row");
      attr(label2, "for", "sctime");
      attr(input2, "id", "sctimes");
      attr(input2, "type", "date");
      attr(div3, "class", "MC-input-group");
      attr(label3, "for", "ectime");
      attr(input3, "id", "ectime");
      attr(input3, "type", "date");
      attr(div4, "class", "MC-input-group");
      attr(div5, "class", "MC-dimension-row");
      attr(div6, "class", "MC-date-inputs");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div2);
      append(div2, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(
        input0,
        /*smtime*/
        ctx[0]
      );
      append(div2, t2);
      append(div2, div1);
      append(div1, label1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(
        input1,
        /*emtime*/
        ctx[1]
      );
      append(div6, t5);
      append(div6, div5);
      append(div5, div3);
      append(div3, label2);
      append(div3, t7);
      append(div3, input2);
      set_input_value(
        input2,
        /*sctime*/
        ctx[2]
      );
      append(div5, t8);
      append(div5, div4);
      append(div4, label3);
      append(div4, t10);
      append(div4, input3);
      set_input_value(
        input3,
        /*ectime*/
        ctx[3]
      );
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[9]
          ),
          listen(input0, "keyup", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(input0, "change", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[10]
          ),
          listen(input1, "keyup", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(input1, "change", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[11]
          ),
          listen(input2, "keyup", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(input2, "change", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(
            input3,
            "input",
            /*input3_input_handler*/
            ctx[12]
          ),
          listen(input3, "keyup", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          }),
          listen(input3, "change", function() {
            if (is_function(
              /*updated*/
              ctx[6]
            )) ctx[6].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*smtime*/
      1) {
        set_input_value(
          input0,
          /*smtime*/
          ctx[0]
        );
      }
      if (dirty & /*emtime*/
      2) {
        set_input_value(
          input1,
          /*emtime*/
          ctx[1]
        );
      }
      if (dirty & /*sctime*/
      4) {
        set_input_value(
          input2,
          /*sctime*/
          ctx[2]
        );
      }
      if (dirty & /*ectime*/
      8) {
        set_input_value(
          input3,
          /*ectime*/
          ctx[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment7(ctx) {
  let popup;
  let current;
  popup = new Popup_default({
    props: {
      icon: (
        /*icon*/
        ctx[4]
      ),
      text: (
        /*text*/
        ctx[5]
      ),
      active: (
        /*active*/
        ctx[7]
      ),
      reset: (
        /*reset*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popup_changes = {};
      if (dirty & /*icon*/
      16) popup_changes.icon = /*icon*/
      ctx2[4];
      if (dirty & /*text*/
      32) popup_changes.text = /*text*/
      ctx2[5];
      if (dirty & /*active*/
      128) popup_changes.active = /*active*/
      ctx2[7];
      if (dirty & /*$$scope, ectime, updated, sctime, emtime, smtime*/
      8271) {
        popup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popup.$set(popup_changes);
    },
    i(local) {
      if (current) return;
      transition_in(popup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popup, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let active2;
  let { icon = "calendar" } = $$props;
  let { text: text2 = "Date" } = $$props;
  let { updated = () => {
  } } = $$props;
  let { smtime = null } = $$props;
  let { emtime = null } = $$props;
  let { sctime = null } = $$props;
  let { ectime = null } = $$props;
  function reset() {
    $$invalidate(0, smtime = null);
    $$invalidate(1, emtime = null);
    $$invalidate(2, sctime = null);
    $$invalidate(3, ectime = null);
    updated();
  }
  function input0_input_handler() {
    smtime = this.value;
    $$invalidate(0, smtime);
  }
  function input1_input_handler() {
    emtime = this.value;
    $$invalidate(1, emtime);
  }
  function input2_input_handler() {
    sctime = this.value;
    $$invalidate(2, sctime);
  }
  function input3_input_handler() {
    ectime = this.value;
    $$invalidate(3, ectime);
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(4, icon = $$props2.icon);
    if ("text" in $$props2) $$invalidate(5, text2 = $$props2.text);
    if ("updated" in $$props2) $$invalidate(6, updated = $$props2.updated);
    if ("smtime" in $$props2) $$invalidate(0, smtime = $$props2.smtime);
    if ("emtime" in $$props2) $$invalidate(1, emtime = $$props2.emtime);
    if ("sctime" in $$props2) $$invalidate(2, sctime = $$props2.sctime);
    if ("ectime" in $$props2) $$invalidate(3, ectime = $$props2.ectime);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*smtime, emtime, sctime, ectime*/
    15) {
      $: $$invalidate(7, active2 = (smtime && emtime) != null || (sctime && ectime) != null);
    }
  };
  return [
    smtime,
    emtime,
    sctime,
    ectime,
    icon,
    text2,
    updated,
    active2,
    reset,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    input3_input_handler
  ];
}
var DateRange = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      icon: 4,
      text: 5,
      updated: 6,
      smtime: 0,
      emtime: 1,
      sctime: 2,
      ectime: 3
    });
  }
};
var DateRange_default = DateRange;

// src/components/Gallery.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[82] = list[i];
  return child_ctx;
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let div2;
  let div1;
  let div0;
  let colourpicker;
  let updating_color;
  let t0;
  let includeselect0;
  let updating_included;
  let updating_excluded;
  let t1;
  let includeselect1;
  let updating_included_1;
  let updating_excluded_1;
  let t2;
  let includeselect2;
  let updating_included_2;
  let updating_excluded_2;
  let t3;
  let resolution;
  let updating_shape;
  let updating_minX;
  let updating_maxX;
  let updating_minY;
  let updating_maxY;
  let t4;
  let daterange;
  let updating_smtime;
  let updating_emtime;
  let updating_sctime;
  let updating_ectime;
  let t5;
  let t6;
  let t7;
  let hr;
  let t8;
  let div5;
  let div4;
  let div3;
  let t9;
  let current;
  function colourpicker_color_binding(value) {
    ctx[31](value);
  }
  let colourpicker_props = { updated: (
    /*onSearchChange*/
    ctx[30]
  ) };
  if (
    /*color*/
    ctx[9] !== void 0
  ) {
    colourpicker_props.color = /*color*/
    ctx[9];
  }
  colourpicker = new ColourPicker_default({ props: colourpicker_props });
  binding_callbacks.push(() => bind(colourpicker, "color", colourpicker_color_binding));
  function includeselect0_included_binding(value) {
    ctx[32](value);
  }
  function includeselect0_excluded_binding(value) {
    ctx[33](value);
  }
  let includeselect0_props = {
    options: (
      /*possiblePaths*/
      ctx[0]
    ),
    icon: "folder",
    text: "Paths",
    updated: (
      /*onSearchChange*/
      ctx[30]
    )
  };
  if (
    /*includedPaths*/
    ctx[1] !== void 0
  ) {
    includeselect0_props.included = /*includedPaths*/
    ctx[1];
  }
  if (
    /*excludedPaths*/
    ctx[2] !== void 0
  ) {
    includeselect0_props.excluded = /*excludedPaths*/
    ctx[2];
  }
  includeselect0 = new IncludeSelect_default({ props: includeselect0_props });
  binding_callbacks.push(() => bind(includeselect0, "included", includeselect0_included_binding));
  binding_callbacks.push(() => bind(includeselect0, "excluded", includeselect0_excluded_binding));
  function includeselect1_included_binding(value) {
    ctx[34](value);
  }
  function includeselect1_excluded_binding(value) {
    ctx[35](value);
  }
  let includeselect1_props = {
    options: (
      /*possibleTags*/
      ctx[3]
    ),
    icon: "hash",
    text: "Tags",
    updated: (
      /*onSearchChange*/
      ctx[30]
    )
  };
  if (
    /*includedTags*/
    ctx[4] !== void 0
  ) {
    includeselect1_props.included = /*includedTags*/
    ctx[4];
  }
  if (
    /*excludedTags*/
    ctx[5] !== void 0
  ) {
    includeselect1_props.excluded = /*excludedTags*/
    ctx[5];
  }
  includeselect1 = new IncludeSelect_default({ props: includeselect1_props });
  binding_callbacks.push(() => bind(includeselect1, "included", includeselect1_included_binding));
  binding_callbacks.push(() => bind(includeselect1, "excluded", includeselect1_excluded_binding));
  function includeselect2_included_binding(value) {
    ctx[36](value);
  }
  function includeselect2_excluded_binding(value) {
    ctx[37](value);
  }
  let includeselect2_props = {
    options: (
      /*possibleExtensions*/
      ctx[6]
    ),
    icon: "file-question",
    text: "Extension",
    updated: (
      /*onSearchChange*/
      ctx[30]
    )
  };
  if (
    /*includedExtensions*/
    ctx[7] !== void 0
  ) {
    includeselect2_props.included = /*includedExtensions*/
    ctx[7];
  }
  if (
    /*excludedExtensions*/
    ctx[8] !== void 0
  ) {
    includeselect2_props.excluded = /*excludedExtensions*/
    ctx[8];
  }
  includeselect2 = new IncludeSelect_default({ props: includeselect2_props });
  binding_callbacks.push(() => bind(includeselect2, "included", includeselect2_included_binding));
  binding_callbacks.push(() => bind(includeselect2, "excluded", includeselect2_excluded_binding));
  function resolution_shape_binding(value) {
    ctx[38](value);
  }
  function resolution_minX_binding(value) {
    ctx[39](value);
  }
  function resolution_maxX_binding(value) {
    ctx[40](value);
  }
  function resolution_minY_binding(value) {
    ctx[41](value);
  }
  function resolution_maxY_binding(value) {
    ctx[42](value);
  }
  let resolution_props = { updated: (
    /*onSearchChange*/
    ctx[30]
  ) };
  if (
    /*shape*/
    ctx[10] !== void 0
  ) {
    resolution_props.shape = /*shape*/
    ctx[10];
  }
  if (
    /*minX*/
    ctx[11] !== void 0
  ) {
    resolution_props.minX = /*minX*/
    ctx[11];
  }
  if (
    /*maxX*/
    ctx[12] !== void 0
  ) {
    resolution_props.maxX = /*maxX*/
    ctx[12];
  }
  if (
    /*minY*/
    ctx[13] !== void 0
  ) {
    resolution_props.minY = /*minY*/
    ctx[13];
  }
  if (
    /*maxY*/
    ctx[14] !== void 0
  ) {
    resolution_props.maxY = /*maxY*/
    ctx[14];
  }
  resolution = new Resolution_default({ props: resolution_props });
  binding_callbacks.push(() => bind(resolution, "shape", resolution_shape_binding));
  binding_callbacks.push(() => bind(resolution, "minX", resolution_minX_binding));
  binding_callbacks.push(() => bind(resolution, "maxX", resolution_maxX_binding));
  binding_callbacks.push(() => bind(resolution, "minY", resolution_minY_binding));
  binding_callbacks.push(() => bind(resolution, "maxY", resolution_maxY_binding));
  function daterange_smtime_binding(value) {
    ctx[43](value);
  }
  function daterange_emtime_binding(value) {
    ctx[44](value);
  }
  function daterange_sctime_binding(value) {
    ctx[45](value);
  }
  function daterange_ectime_binding(value) {
    ctx[46](value);
  }
  let daterange_props = { updated: (
    /*onSearchChange*/
    ctx[30]
  ) };
  if (
    /*smtime*/
    ctx[15] !== void 0
  ) {
    daterange_props.smtime = /*smtime*/
    ctx[15];
  }
  if (
    /*emtime*/
    ctx[16] !== void 0
  ) {
    daterange_props.emtime = /*emtime*/
    ctx[16];
  }
  if (
    /*sctime*/
    ctx[17] !== void 0
  ) {
    daterange_props.sctime = /*sctime*/
    ctx[17];
  }
  if (
    /*ectime*/
    ctx[18] !== void 0
  ) {
    daterange_props.ectime = /*ectime*/
    ctx[18];
  }
  daterange = new DateRange_default({ props: daterange_props });
  binding_callbacks.push(() => bind(daterange, "smtime", daterange_smtime_binding));
  binding_callbacks.push(() => bind(daterange, "emtime", daterange_emtime_binding));
  binding_callbacks.push(() => bind(daterange, "sctime", daterange_sctime_binding));
  binding_callbacks.push(() => bind(daterange, "ectime", daterange_ectime_binding));
  let if_block0 = import_obsidian5.Platform.isMobile && create_if_block_1(ctx);
  let if_block1 = !import_obsidian5.Platform.isMobile && create_if_block2(ctx);
  let each_value = ensure_array_like(
    /*items*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(colourpicker.$$.fragment);
      t0 = space();
      create_component(includeselect0.$$.fragment);
      t1 = space();
      create_component(includeselect1.$$.fragment);
      t2 = space();
      create_component(includeselect2.$$.fragment);
      t3 = space();
      create_component(resolution.$$.fragment);
      t4 = space();
      create_component(daterange.$$.fragment);
      t5 = space();
      if (if_block0) if_block0.c();
      t6 = space();
      if (if_block1) if_block1.c();
      t7 = space();
      hr = element("hr");
      t8 = space();
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      t9 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "MC-gallery-search");
      attr(div1, "class", "MC-search-controls-container");
      attr(div2, "class", "MC-search-controls-scroll-wrapper");
      attr(hr, "class", "MC-gallery-search-hr");
      attr(div3, "class", "MC-gallery-sizer");
      set_style(
        div3,
        "width",
        /*elementSize*/
        ctx[19] + "px"
      );
      attr(div4, "class", "MC-gallery-masonry");
      attr(div5, "class", "MC-gallery-container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(colourpicker, div0, null);
      append(div0, t0);
      mount_component(includeselect0, div0, null);
      append(div0, t1);
      mount_component(includeselect1, div0, null);
      append(div0, t2);
      mount_component(includeselect2, div0, null);
      append(div0, t3);
      mount_component(resolution, div0, null);
      append(div0, t4);
      mount_component(daterange, div0, null);
      append(div0, t5);
      if (if_block0) if_block0.m(div0, null);
      append(div1, t6);
      if (if_block1) if_block1.m(div1, null);
      insert(target, t7, anchor);
      insert(target, hr, anchor);
      insert(target, t8, anchor);
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div4, t9);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      ctx[57](div4);
      ctx[58](div5);
      current = true;
    },
    p(ctx2, dirty) {
      const colourpicker_changes = {};
      if (!updating_color && dirty[0] & /*color*/
      512) {
        updating_color = true;
        colourpicker_changes.color = /*color*/
        ctx2[9];
        add_flush_callback(() => updating_color = false);
      }
      colourpicker.$set(colourpicker_changes);
      const includeselect0_changes = {};
      if (dirty[0] & /*possiblePaths*/
      1) includeselect0_changes.options = /*possiblePaths*/
      ctx2[0];
      if (!updating_included && dirty[0] & /*includedPaths*/
      2) {
        updating_included = true;
        includeselect0_changes.included = /*includedPaths*/
        ctx2[1];
        add_flush_callback(() => updating_included = false);
      }
      if (!updating_excluded && dirty[0] & /*excludedPaths*/
      4) {
        updating_excluded = true;
        includeselect0_changes.excluded = /*excludedPaths*/
        ctx2[2];
        add_flush_callback(() => updating_excluded = false);
      }
      includeselect0.$set(includeselect0_changes);
      const includeselect1_changes = {};
      if (dirty[0] & /*possibleTags*/
      8) includeselect1_changes.options = /*possibleTags*/
      ctx2[3];
      if (!updating_included_1 && dirty[0] & /*includedTags*/
      16) {
        updating_included_1 = true;
        includeselect1_changes.included = /*includedTags*/
        ctx2[4];
        add_flush_callback(() => updating_included_1 = false);
      }
      if (!updating_excluded_1 && dirty[0] & /*excludedTags*/
      32) {
        updating_excluded_1 = true;
        includeselect1_changes.excluded = /*excludedTags*/
        ctx2[5];
        add_flush_callback(() => updating_excluded_1 = false);
      }
      includeselect1.$set(includeselect1_changes);
      const includeselect2_changes = {};
      if (dirty[0] & /*possibleExtensions*/
      64) includeselect2_changes.options = /*possibleExtensions*/
      ctx2[6];
      if (!updating_included_2 && dirty[0] & /*includedExtensions*/
      128) {
        updating_included_2 = true;
        includeselect2_changes.included = /*includedExtensions*/
        ctx2[7];
        add_flush_callback(() => updating_included_2 = false);
      }
      if (!updating_excluded_2 && dirty[0] & /*excludedExtensions*/
      256) {
        updating_excluded_2 = true;
        includeselect2_changes.excluded = /*excludedExtensions*/
        ctx2[8];
        add_flush_callback(() => updating_excluded_2 = false);
      }
      includeselect2.$set(includeselect2_changes);
      const resolution_changes = {};
      if (!updating_shape && dirty[0] & /*shape*/
      1024) {
        updating_shape = true;
        resolution_changes.shape = /*shape*/
        ctx2[10];
        add_flush_callback(() => updating_shape = false);
      }
      if (!updating_minX && dirty[0] & /*minX*/
      2048) {
        updating_minX = true;
        resolution_changes.minX = /*minX*/
        ctx2[11];
        add_flush_callback(() => updating_minX = false);
      }
      if (!updating_maxX && dirty[0] & /*maxX*/
      4096) {
        updating_maxX = true;
        resolution_changes.maxX = /*maxX*/
        ctx2[12];
        add_flush_callback(() => updating_maxX = false);
      }
      if (!updating_minY && dirty[0] & /*minY*/
      8192) {
        updating_minY = true;
        resolution_changes.minY = /*minY*/
        ctx2[13];
        add_flush_callback(() => updating_minY = false);
      }
      if (!updating_maxY && dirty[0] & /*maxY*/
      16384) {
        updating_maxY = true;
        resolution_changes.maxY = /*maxY*/
        ctx2[14];
        add_flush_callback(() => updating_maxY = false);
      }
      resolution.$set(resolution_changes);
      const daterange_changes = {};
      if (!updating_smtime && dirty[0] & /*smtime*/
      32768) {
        updating_smtime = true;
        daterange_changes.smtime = /*smtime*/
        ctx2[15];
        add_flush_callback(() => updating_smtime = false);
      }
      if (!updating_emtime && dirty[0] & /*emtime*/
      65536) {
        updating_emtime = true;
        daterange_changes.emtime = /*emtime*/
        ctx2[16];
        add_flush_callback(() => updating_emtime = false);
      }
      if (!updating_sctime && dirty[0] & /*sctime*/
      131072) {
        updating_sctime = true;
        daterange_changes.sctime = /*sctime*/
        ctx2[17];
        add_flush_callback(() => updating_sctime = false);
      }
      if (!updating_ectime && dirty[0] & /*ectime*/
      262144) {
        updating_ectime = true;
        daterange_changes.ectime = /*ectime*/
        ctx2[18];
        add_flush_callback(() => updating_ectime = false);
      }
      daterange.$set(daterange_changes);
      if (import_obsidian5.Platform.isMobile) if_block0.p(ctx2, dirty);
      if (!import_obsidian5.Platform.isMobile) if_block1.p(ctx2, dirty);
      if (!current || dirty[0] & /*elementSize*/
      524288) {
        set_style(
          div3,
          "width",
          /*elementSize*/
          ctx2[19] + "px"
        );
      }
      if (dirty[0] & /*elementSize, onFileClicked, items, reloadMasonry*/
      822607872) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[24]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div4, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(colourpicker.$$.fragment, local);
      transition_in(includeselect0.$$.fragment, local);
      transition_in(includeselect1.$$.fragment, local);
      transition_in(includeselect2.$$.fragment, local);
      transition_in(resolution.$$.fragment, local);
      transition_in(daterange.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(colourpicker.$$.fragment, local);
      transition_out(includeselect0.$$.fragment, local);
      transition_out(includeselect1.$$.fragment, local);
      transition_out(includeselect2.$$.fragment, local);
      transition_out(resolution.$$.fragment, local);
      transition_out(daterange.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t7);
        detach(hr);
        detach(t8);
        detach(div5);
      }
      destroy_component(colourpicker);
      destroy_component(includeselect0);
      destroy_component(includeselect1);
      destroy_component(includeselect2);
      destroy_component(resolution);
      destroy_component(daterange);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_each(each_blocks, detaching);
      ctx[57](null);
      ctx[58](null);
    }
  };
}
function create_if_block_1(ctx) {
  let order;
  let updating_option;
  let updating_orderIncreasing;
  let current;
  function order_option_binding(value) {
    ctx[47](value);
  }
  function order_orderIncreasing_binding(value) {
    ctx[48](value);
  }
  let order_props = { updated: (
    /*onSearchChange*/
    ctx[30]
  ) };
  if (
    /*orderBy*/
    ctx[20] !== void 0
  ) {
    order_props.option = /*orderBy*/
    ctx[20];
  }
  if (
    /*orderIncreasing*/
    ctx[21] !== void 0
  ) {
    order_props.orderIncreasing = /*orderIncreasing*/
    ctx[21];
  }
  order = new Order_default({ props: order_props });
  binding_callbacks.push(() => bind(order, "option", order_option_binding));
  binding_callbacks.push(() => bind(order, "orderIncreasing", order_orderIncreasing_binding));
  return {
    c() {
      create_component(order.$$.fragment);
    },
    m(target, anchor) {
      mount_component(order, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const order_changes = {};
      if (!updating_option && dirty[0] & /*orderBy*/
      1048576) {
        updating_option = true;
        order_changes.option = /*orderBy*/
        ctx2[20];
        add_flush_callback(() => updating_option = false);
      }
      if (!updating_orderIncreasing && dirty[0] & /*orderIncreasing*/
      2097152) {
        updating_orderIncreasing = true;
        order_changes.orderIncreasing = /*orderIncreasing*/
        ctx2[21];
        add_flush_callback(() => updating_orderIncreasing = false);
      }
      order.$set(order_changes);
    },
    i(local) {
      if (current) return;
      transition_in(order.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(order.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(order, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div3;
  let div0;
  let t0;
  let input;
  let t1;
  let div1;
  let t2;
  let div2;
  let t3;
  let order;
  let updating_option;
  let updating_orderIncreasing;
  let current;
  let mounted;
  let dispose;
  function order_option_binding_1(value) {
    ctx[53](value);
  }
  function order_orderIncreasing_binding_1(value) {
    ctx[54](value);
  }
  let order_props = { updated: (
    /*onSearchChange*/
    ctx[30]
  ) };
  if (
    /*orderBy*/
    ctx[20] !== void 0
  ) {
    order_props.option = /*orderBy*/
    ctx[20];
  }
  if (
    /*orderIncreasing*/
    ctx[21] !== void 0
  ) {
    order_props.orderIncreasing = /*orderIncreasing*/
    ctx[21];
  }
  order = new Order_default({ props: order_props });
  binding_callbacks.push(() => bind(order, "option", order_option_binding_1));
  binding_callbacks.push(() => bind(order, "orderIncreasing", order_orderIncreasing_binding_1));
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<span></span>`;
      t0 = space();
      input = element("input");
      t1 = space();
      div1 = element("div");
      div1.innerHTML = `<span></span>`;
      t2 = space();
      div2 = element("div");
      t3 = space();
      create_component(order.$$.fragment);
      attr(div0, "class", "MC-gallery-sizer-icon");
      attr(input, "class", "MC-gallery-sizer");
      attr(input, "type", "range");
      attr(input, "min", minElementSize);
      attr(input, "max", maxElementSize);
      attr(div1, "class", "MC-gallery-sizer-icon");
      attr(div2, "class", "MC-gallery-empty");
      attr(div3, "class", "MC-gallery-controls-right");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      ctx[49](div0);
      append(div3, t0);
      append(div3, input);
      set_input_value(
        input,
        /*elementSize*/
        ctx[19]
      );
      append(div3, t1);
      append(div3, div1);
      ctx[52](div1);
      append(div3, t2);
      append(div3, div2);
      append(div3, t3);
      mount_component(order, div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[50]
          ),
          listen(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[50]
          ),
          listen(
            input,
            "input",
            /*input_handler*/
            ctx[51]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*elementSize*/
      524288) {
        set_input_value(
          input,
          /*elementSize*/
          ctx2[19]
        );
      }
      const order_changes = {};
      if (!updating_option && dirty[0] & /*orderBy*/
      1048576) {
        updating_option = true;
        order_changes.option = /*orderBy*/
        ctx2[20];
        add_flush_callback(() => updating_option = false);
      }
      if (!updating_orderIncreasing && dirty[0] & /*orderIncreasing*/
      2097152) {
        updating_orderIncreasing = true;
        order_changes.orderIncreasing = /*orderIncreasing*/
        ctx2[21];
        add_flush_callback(() => updating_orderIncreasing = false);
      }
      order.$set(order_changes);
    },
    i(local) {
      if (current) return;
      transition_in(order.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(order.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      ctx[49](null);
      ctx[52](null);
      destroy_component(order);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block3(ctx) {
  let button;
  let mediafileembed;
  let t;
  let current;
  let mounted;
  let dispose;
  mediafileembed = new MediaFileEmbed_default({
    props: {
      file: (
        /*item*/
        ctx[82].file.file
      ),
      recomputeDimensions: (
        /*func*/
        ctx[55]
      )
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[56](
        /*item*/
        ctx[82]
      )
    );
  }
  return {
    c() {
      button = element("button");
      create_component(mediafileembed.$$.fragment);
      t = space();
      attr(button, "class", "MC-gallery-item");
      set_style(
        button,
        "width",
        /*elementSize*/
        ctx[19] + "px"
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(mediafileembed, button, null);
      append(button, t);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const mediafileembed_changes = {};
      if (dirty[0] & /*items*/
      16777216) mediafileembed_changes.file = /*item*/
      ctx[82].file.file;
      mediafileembed.$set(mediafileembed_changes);
      if (!current || dirty[0] & /*elementSize*/
      524288) {
        set_style(
          button,
          "width",
          /*elementSize*/
          ctx[19] + "px"
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(mediafileembed.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mediafileembed.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(mediafileembed);
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block(ctx) {
  let h1;
  return {
    c() {
      h1 = element("h1");
      h1.textContent = "Loading cache...";
      attr(h1, "class", "MC-gallery-loading");
    },
    m(target, anchor) {
      insert(target, h1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h1);
      }
    }
  };
}
function create_fragment8(ctx) {
  let div;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    blocks: [, , ,]
  };
  handle_promise(promise = /*plugin*/
  ctx[27].cache.initialize(), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "MC-gallery-view-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current) return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
var minElementSize = 100;
var maxElementSize = 500;
var groupSize = 20;
function getTouchDistance(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function instance8($$self, $$props, $$invalidate) {
  let plugin2 = get_store_value(pluginStore_default.plugin);
  let app2 = get_store_value(appStore_default.app);
  let possiblePaths = [];
  let includedPaths = [];
  let excludedPaths = [];
  let possibleTags = [];
  let includedTags = [];
  let excludedTags = [];
  let possibleExtensions = [];
  let includedExtensions = [];
  let excludedExtensions = [];
  let color = null;
  let shape = null;
  let minX = null;
  let maxX = null;
  let minY = null;
  let maxY = null;
  let smtime = null;
  let emtime = null;
  let sctime = null;
  let ectime = null;
  let elementSize = 200;
  let orderBy = "name" /* name */;
  let orderIncreasing = true;
  let masonry;
  let masonryContainer;
  let scrollContainer;
  let items = [];
  let allItems = [];
  let query = new Query(plugin2.cache);
  let sizerMinus;
  let sizerPlus;
  let isLoading = false;
  let currentGroup = 0;
  const resizeObserver = new ResizeObserver(() => onResize());
  plugin2.mutationHandler.addEventListener("file-created", onNewFile);
  plugin2.mutationHandler.addEventListener("file-removed", onFileRemoved);
  plugin2.mutationHandler.addEventListener("file-changed", onFileChanged);
  plugin2.mutationHandler.addEventListener("file-moved", onFileMoved);
  plugin2.mutationHandler.addEventListener("sidecar-edited", onFileChanged);
  function getDisplayItem(file2) {
    return {
      uri: app2.vault.getResourcePath(file2.file),
      file: file2
    };
  }
  function onFileMoved(e) {
    updateSearchPossibilities();
    let allFilesIndex = allItems.findIndex((item) => item.file.path === e.detail.oldPath);
    let itemsIndex = items.findIndex((item) => item.file.file.path === e.detail.oldPath);
    query.testFile(e.detail.file).then((res) => {
      if (res) {
        if (allFilesIndex === -1) {
          allItems = [e.detail.file, ...allItems];
        } else {
          allItems[allFilesIndex] = e.detail.file;
        }
        if (itemsIndex === -1) {
          $$invalidate(24, items = [getDisplayItem(e.detail.file), ...items]);
        } else {
          $$invalidate(24, items[itemsIndex] = getDisplayItem(e.detail.file), items);
        }
      } else {
        if (allFilesIndex !== -1) {
          allItems = allItems.splice(allFilesIndex, 1);
        }
        if (itemsIndex !== -1) {
          $$invalidate(24, items = items.splice(itemsIndex, 1));
        }
      }
      $$invalidate(24, items = [...items]);
      reloadMasonry();
    });
  }
  function onNewFile(e) {
    updateSearchPossibilities();
    if (query) {
      query.testFile(e.detail).then((res) => {
        if (res) {
          allItems = [e.detail, ...allItems];
          $$invalidate(24, items = [getDisplayItem(e.detail), ...items]);
          reloadMasonry();
        }
      });
    }
  }
  function onFileRemoved(e) {
    updateSearchPossibilities();
    allItems = allItems.filter((item) => item !== e.detail);
    $$invalidate(24, items = items.filter((item) => item.file !== e.detail));
    $$invalidate(24, items = [...items]);
    reloadMasonry();
  }
  function onFileChanged(e) {
    updateSearchPossibilities();
    let allFilesIndex = allItems.findIndex((item) => item === e.detail);
    let itemsIndex = items.findIndex((item) => item.file === e.detail);
    query.testFile(e.detail).then((res) => {
      if (res) {
        if (allFilesIndex === -1) {
          allItems = [e.detail, ...allItems];
        }
        if (itemsIndex === -1) {
          $$invalidate(24, items = [getDisplayItem(e.detail), ...items]);
        }
      } else {
        if (allFilesIndex !== -1) {
          allItems = allItems.splice(allFilesIndex, 1);
        }
        if (itemsIndex !== -1) {
          $$invalidate(24, items = items.splice(itemsIndex, 1));
        }
      }
      $$invalidate(24, items = [...items]);
      reloadMasonry();
    });
  }
  function onResize() {
    if (scrollContainer && masonryContainer && masonryContainer.offsetParent !== null) {
      reloadMasonry();
      reloadMasonry();
      if (!isScrollbarVisible()) {
        loadNextGroup().then(() => {
        });
      }
    }
  }
  function loadNextGroup() {
    return __awaiter(this, void 0, void 0, function* () {
      isLoading = true;
      const startIndex = currentGroup * groupSize;
      const endIndex = startIndex + groupSize;
      if (startIndex >= allItems.length) return;
      const nextGroup = allItems.slice(startIndex, endIndex);
      let formattedGroup = nextGroup.map((item) => {
        return getDisplayItem(item);
      });
      $$invalidate(24, items = [...items, ...formattedGroup]);
      yield tick();
      reloadMasonry();
      currentGroup++;
      yield new Promise((resolve) => setTimeout(resolve, 50));
      if (!isScrollbarVisible()) {
        yield new Promise((resolve) => setTimeout(resolve, 500));
        yield loadNextGroup();
      } else {
        isLoading = false;
      }
    });
  }
  function reloadMasonry() {
    if (masonry && masonryContainer) {
      (0, import_imagesloaded.default)(masonryContainer, () => {
        masonry.reloadItems();
        masonry.layout();
      });
    }
  }
  function onScroll() {
    if (!scrollContainer) return;
    const nearBottom = scrollContainer.scrollTop + scrollContainer.clientHeight >= scrollContainer.scrollHeight - 100;
    if (nearBottom && !isLoading) loadNextGroup();
  }
  function isScrollbarVisible() {
    return scrollContainer.scrollHeight > scrollContainer.clientHeight && scrollContainer.clientHeight != 0;
  }
  function updateSearchPossibilities() {
    $$invalidate(0, possiblePaths = [...Object.entries(plugin2.cache.paths)]);
    possiblePaths.sort((a, b) => a[0].localeCompare(b[0]));
    $$invalidate(3, possibleTags = [...Object.entries(plugin2.cache.tags)]);
    possibleTags.sort((a, b) => a[0].localeCompare(b[0]));
    $$invalidate(6, possibleExtensions = [...Object.entries(plugin2.cache.extensions)]);
    possibleExtensions.sort((a, b) => a[0].localeCompare(b[0]));
  }
  let pinchInitialDistance = 0;
  let pinchInitialSize = 0;
  function onTouchStart(e) {
    if (e.touches.length === 2) {
      pinchInitialDistance = getTouchDistance(e);
      pinchInitialSize = elementSize;
      e.preventDefault();
    }
  }
  function onTouchMove(e) {
    if (e.touches.length === 2) {
      const currentDistance = getTouchDistance(e);
      if (pinchInitialDistance > 0) {
        const scale = currentDistance / pinchInitialDistance;
        $$invalidate(19, elementSize = Math.min(maxElementSize, Math.max(minElementSize, Math.round(pinchInitialSize * scale))));
        reloadMasonry();
        e.preventDefault();
      }
    }
  }
  function onTouchEnd() {
    pinchInitialDistance = 0;
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    yield plugin2.cache.initialize();
    allItems = yield query.getItems();
    if (sizerMinus && sizerPlus) {
      (0, import_obsidian5.setIcon)(sizerMinus, "minus");
      (0, import_obsidian5.setIcon)(sizerPlus, "plus");
    }
    updateSearchPossibilities();
    masonry = new import_masonry_layout.default(
      masonryContainer,
      {
        transitionDuration: 0,
        // Turn off animations; Looks weird when adding items
        columnWidth: ".MC-gallery-sizer",
        itemSelector: ".MC-gallery-item",
        fitWidth: true
      }
    );
    yield loadNextGroup();
    resizeObserver.observe(scrollContainer);
    scrollContainer.addEventListener("scroll", onScroll);
    scrollContainer.addEventListener("touchstart", onTouchStart, { passive: false });
    scrollContainer.addEventListener("touchmove", onTouchMove, { passive: false });
    scrollContainer.addEventListener("touchend", onTouchEnd);
  }));
  onDestroy(() => {
    scrollContainer.removeEventListener("scroll", onScroll);
    scrollContainer.removeEventListener("touchstart", onTouchStart);
    scrollContainer.removeEventListener("touchmove", onTouchMove);
    scrollContainer.removeEventListener("touchend", onTouchEnd);
    if (resizeObserver) {
      resizeObserver.disconnect();
    }
    plugin2.mutationHandler.removeEventListener("file-created", onNewFile);
    plugin2.mutationHandler.removeEventListener("file-removed", onFileRemoved);
    plugin2.mutationHandler.removeEventListener("file-changed", onFileChanged);
    plugin2.mutationHandler.removeEventListener("file-moved", onFileChanged);
    plugin2.mutationHandler.removeEventListener("sidecar-edited", onFileChanged);
  });
  function onFileClicked(file2) {
    activeStore_default.file.set(file2);
  }
  let searchDebounce = (0, import_obsidian6.debounce)(
    () => __awaiter(void 0, void 0, void 0, function* () {
      $$invalidate(24, items = []);
      currentGroup = 0;
      query = new Query(
        plugin2.cache,
        {
          name: "",
          folders: {
            included: includedPaths,
            excluded: excludedPaths
          },
          tags: {
            included: includedTags,
            excluded: excludedTags
          },
          fileTypes: {
            included: includedExtensions,
            excluded: excludedExtensions
          },
          shape,
          color,
          dimensions: {
            minWidth: minX,
            maxWidth: maxX,
            minHeight: minY,
            maxHeight: maxY
          },
          date: {
            startCtime: sctime ? new Date(sctime) : null,
            endCtime: ectime ? new Date(ectime) : null,
            startMtime: smtime ? new Date(smtime) : null,
            endMtime: emtime ? new Date(emtime) : null
          },
          orderBy,
          orderIncreasing
        }
      );
      allItems = yield query.getItems();
      yield loadNextGroup();
      reloadMasonry();
    }),
    300,
    true
  );
  function onSearchChange() {
    searchDebounce();
  }
  function colourpicker_color_binding(value) {
    color = value;
    $$invalidate(9, color);
  }
  function includeselect0_included_binding(value) {
    includedPaths = value;
    $$invalidate(1, includedPaths);
  }
  function includeselect0_excluded_binding(value) {
    excludedPaths = value;
    $$invalidate(2, excludedPaths);
  }
  function includeselect1_included_binding(value) {
    includedTags = value;
    $$invalidate(4, includedTags);
  }
  function includeselect1_excluded_binding(value) {
    excludedTags = value;
    $$invalidate(5, excludedTags);
  }
  function includeselect2_included_binding(value) {
    includedExtensions = value;
    $$invalidate(7, includedExtensions);
  }
  function includeselect2_excluded_binding(value) {
    excludedExtensions = value;
    $$invalidate(8, excludedExtensions);
  }
  function resolution_shape_binding(value) {
    shape = value;
    $$invalidate(10, shape);
  }
  function resolution_minX_binding(value) {
    minX = value;
    $$invalidate(11, minX);
  }
  function resolution_maxX_binding(value) {
    maxX = value;
    $$invalidate(12, maxX);
  }
  function resolution_minY_binding(value) {
    minY = value;
    $$invalidate(13, minY);
  }
  function resolution_maxY_binding(value) {
    maxY = value;
    $$invalidate(14, maxY);
  }
  function daterange_smtime_binding(value) {
    smtime = value;
    $$invalidate(15, smtime);
  }
  function daterange_emtime_binding(value) {
    emtime = value;
    $$invalidate(16, emtime);
  }
  function daterange_sctime_binding(value) {
    sctime = value;
    $$invalidate(17, sctime);
  }
  function daterange_ectime_binding(value) {
    ectime = value;
    $$invalidate(18, ectime);
  }
  function order_option_binding(value) {
    orderBy = value;
    $$invalidate(20, orderBy);
  }
  function order_orderIncreasing_binding(value) {
    orderIncreasing = value;
    $$invalidate(21, orderIncreasing);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      sizerMinus = $$value;
      $$invalidate(25, sizerMinus);
    });
  }
  function input_change_input_handler() {
    elementSize = to_number(this.value);
    $$invalidate(19, elementSize);
  }
  const input_handler = () => reloadMasonry();
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      sizerPlus = $$value;
      $$invalidate(26, sizerPlus);
    });
  }
  function order_option_binding_1(value) {
    orderBy = value;
    $$invalidate(20, orderBy);
  }
  function order_orderIncreasing_binding_1(value) {
    orderIncreasing = value;
    $$invalidate(21, orderIncreasing);
  }
  const func2 = () => reloadMasonry();
  const click_handler = (item) => onFileClicked(item.file);
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      masonryContainer = $$value;
      $$invalidate(22, masonryContainer);
    });
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollContainer = $$value;
      $$invalidate(23, scrollContainer);
    });
  }
  return [
    possiblePaths,
    includedPaths,
    excludedPaths,
    possibleTags,
    includedTags,
    excludedTags,
    possibleExtensions,
    includedExtensions,
    excludedExtensions,
    color,
    shape,
    minX,
    maxX,
    minY,
    maxY,
    smtime,
    emtime,
    sctime,
    ectime,
    elementSize,
    orderBy,
    orderIncreasing,
    masonryContainer,
    scrollContainer,
    items,
    sizerMinus,
    sizerPlus,
    plugin2,
    reloadMasonry,
    onFileClicked,
    onSearchChange,
    colourpicker_color_binding,
    includeselect0_included_binding,
    includeselect0_excluded_binding,
    includeselect1_included_binding,
    includeselect1_excluded_binding,
    includeselect2_included_binding,
    includeselect2_excluded_binding,
    resolution_shape_binding,
    resolution_minX_binding,
    resolution_maxX_binding,
    resolution_minY_binding,
    resolution_maxY_binding,
    daterange_smtime_binding,
    daterange_emtime_binding,
    daterange_sctime_binding,
    daterange_ectime_binding,
    order_option_binding,
    order_orderIncreasing_binding,
    div0_binding,
    input_change_input_handler,
    input_handler,
    div1_binding,
    order_option_binding_1,
    order_orderIncreasing_binding_1,
    func2,
    click_handler,
    div4_binding,
    div5_binding
  ];
}
var Gallery = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {}, null, [-1, -1, -1]);
  }
};
var Gallery_default = Gallery;

// src/views/gallery-view.ts
var VIEW_TYPE_GALLERY = "gallery-view";
var GalleryView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
  }
  getViewType() {
    return VIEW_TYPE_GALLERY;
  }
  getDisplayText() {
    return "Gallery view";
  }
  getIcon() {
    return "image";
  }
  async onOpen() {
    this.contentEl.addClass("MC-gallery-page-container");
    this.component = new Gallery_default({
      target: this.contentEl,
      props: {}
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  hideSidecar: true,
  extensions: [
    "png",
    "jpg",
    "jpeg",
    "bmp",
    "avif",
    "webp",
    "gif"
  ],
  sidecarTemplate: ""
};

// src/mutationHandler.ts
var import_obsidian8 = require("obsidian");
var MutationHandler = class extends EventTarget {
  constructor(app2, plugin2, cache) {
    super();
    this.app = app2;
    this.plugin = plugin2;
    this.cache = cache;
  }
  initializeEvents() {
    this.plugin.registerEvent(this.app.vault.on("create", this.onFileCreated.bind(this)));
    this.plugin.registerEvent(this.app.vault.on("delete", this.onDeleted.bind(this)));
    this.plugin.registerEvent(this.app.vault.on("rename", this.onMoved.bind(this)));
    this.plugin.registerEvent(this.app.vault.on("modify", this.onFileEdited.bind(this)));
  }
  /**
      * Callback for file editing
      * @param file The edited file
      */
  onFileEdited(file2) {
    if (!(file2 instanceof import_obsidian8.TFile)) return;
    const isMarkdown = file2.extension === "md";
    let mediaPath = file2.path;
    if (isMarkdown && !file2.path.endsWith(Sidecar.EXTENSION)) return;
    if (isMarkdown) {
      mediaPath = file2.path.substring(0, file2.path.length - Sidecar.EXTENSION.length);
    }
    const f = this.cache.getFile(mediaPath);
    if (f) {
      f.update().then(() => {
      });
      if (isMarkdown) {
        this.cache.sidecarUpdated(f);
        this.dispatchEvent(new CustomEvent("sidecar-edited", { detail: f }));
      } else {
        this.dispatchEvent(new CustomEvent("file-edited", { detail: f }));
      }
    }
  }
  /**
      * Callback for file deletion
      * @param file The deleted file
      */
  onDeleted(file2) {
    if (!(file2 instanceof import_obsidian8.TFile)) return;
    const isSidecar = this.cache.isSidecar(file2);
    if (isSidecar) {
      const mediaPath = file2.path.substring(0, file2.path.length - 11);
      const mediaFile = this.app.vault.getFileByPath(mediaPath);
      if (mediaFile) this.onFileCreated(mediaFile);
    }
    if (!this.plugin.settings.extensions.contains(file2.extension.toLowerCase())) return;
    const f = this.cache.getFile(file2.path);
    this.cache.removeFile(file2);
    if (f) {
      this.dispatchEvent(new CustomEvent("file-deleted", { detail: f }));
    }
    const sidecar = this.app.vault.getFileByPath(`${file2.path}${Sidecar.EXTENSION}`);
    if (sidecar) {
      this.app.fileManager.trashFile(sidecar).then(() => {
      });
    }
  }
  /**
      * Callback for file moving or renaming
      * @param file The new file
      * @param oldpath The old path of the file
      */
  onMoved(file2, oldpath) {
    if (!(file2 instanceof import_obsidian8.TFile)) return;
    const isSidecar = this.cache.isSidecarFromPath(oldpath);
    if (isSidecar) {
      const mediaPath = oldpath.substring(0, oldpath.length - Sidecar.EXTENSION.length);
      const mediaFile = this.app.vault.getFileByPath(mediaPath);
      if (mediaFile) {
        this.onFileCreated(mediaFile);
      }
    }
    if (!this.plugin.settings.extensions.contains(file2.extension.toLowerCase())) return;
    const cacheFile = this.cache.getFile(file2.path);
    const sidecar = this.app.vault.getFileByPath(`${oldpath}${Sidecar.EXTENSION}`);
    if (sidecar) {
      this.app.fileManager.renameFile(sidecar, `${file2.path}${Sidecar.EXTENSION}`).then(() => {
      });
    }
    if (!cacheFile) {
      this.createMediaFile(file2, sidecar).then((mediaFile) => {
        if (mediaFile) {
          this.cache.fileMoved(mediaFile, oldpath);
          this.dispatchEvent(new CustomEvent("file-moved", { detail: { file: mediaFile, oldPath: oldpath } }));
        }
      });
    }
  }
  /**
      * Callback for file creation
      * @param file The created file
      */
  onFileCreated(file2) {
    this.createMediaFile(file2).then((mediaFile) => {
      if (mediaFile) {
        this.dispatchEvent(new CustomEvent("file-created", { detail: mediaFile }));
      }
    });
  }
  /**
   * Created a MediaFile of the correct type. E.g.; For an image, an MCImage will be made.
   * @param file The file to be made a mediaFile for. Will be checked to be of type TFile and whether its
   * extension is in the current plugin settings
   * @param sidecar The sidecar file, if there is already one. For example, if the file has been moved.
   * @returns The created media file, of the correct type, or null if none was created
   */
  async createMediaFile(file2, sidecar = null) {
    if (!(file2 instanceof import_obsidian8.TFile) || !this.plugin.settings.extensions.contains(file2.extension.toLowerCase())) return null;
    if (this.cache.getFile(file2.path)) return null;
    let mediaFile = null;
    switch (getMediaType(file2.extension)) {
      case "image" /* Image */:
        mediaFile = await MCImage.create(file2, this.app, this.plugin, sidecar);
        break;
      case "unknown" /* Unknown */:
        mediaFile = await MediaFile.create(file2, this.app, this.plugin, sidecar);
        break;
    }
    if (mediaFile) {
      this.cache.addFile(mediaFile);
    }
    return mediaFile;
  }
};

// src/views/sidecar-view.ts
var import_obsidian11 = require("obsidian");

// src/components/Sidecar.svelte
var import_obsidian9 = require("obsidian");
var import_obsidian10 = require("obsidian");
function create_if_block_2(ctx) {
  let div;
  let mediafileembed;
  let current;
  mediafileembed = new MediaFileEmbed_default({ props: { file: (
    /*file*/
    ctx[0].file
  ) } });
  return {
    c() {
      div = element("div");
      create_component(mediafileembed.$$.fragment);
      attr(div, "class", "MC-embed-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(mediafileembed, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const mediafileembed_changes = {};
      if (dirty & /*file*/
      1) mediafileembed_changes.file = /*file*/
      ctx2[0].file;
      mediafileembed.$set(mediafileembed_changes);
    },
    i(local) {
      if (current) return;
      transition_in(mediafileembed.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mediafileembed.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(mediafileembed);
    }
  };
}
function create_if_block_12(ctx) {
  let h3;
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "No file selected";
      attr(h3, "class", "MC-sidecar-nofile");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_if_block3(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Invalid filename";
      attr(p, "class", "MC-sidecar-title-message");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment9(ctx) {
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let textarea;
  let textarea_hidden_value;
  let t1;
  let t2;
  let div0;
  let div0_hidden_value;
  let t3;
  let div1;
  let div1_hidden_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_12, create_if_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*file*/
    ctx2[0]) return 0;
    if (
      /*file*/
      ctx2[0].file
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*invalidName*/
    ctx[5] && create_if_block3(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      textarea = element("textarea");
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div0 = element("div");
      t3 = space();
      div1 = element("div");
      attr(textarea, "class", "MC-sidecar-title");
      textarea.hidden = textarea_hidden_value = !/*file*/
      ctx[0];
      toggle_class(
        textarea,
        "MC-sidecar-title-invalid",
        /*invalidName*/
        ctx[5]
      );
      div0.hidden = div0_hidden_value = !/*file*/
      ctx[0];
      attr(div0, "class", "MC-sidecar-metadata");
      div1.hidden = div1_hidden_value = !/*file*/
      ctx[0];
      attr(div1, "class", "MC-sidecar-editor");
      attr(div2, "class", "MC-sidecar-container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t0);
      append(div2, textarea);
      set_input_value(
        textarea,
        /*title*/
        ctx[4]
      );
      ctx[7](textarea);
      append(div2, t1);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t2);
      append(div2, div0);
      ctx[8](div0);
      append(div2, t3);
      append(div2, div1);
      ctx[9](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        } else {
          if_block0 = null;
        }
      }
      if (!current || dirty & /*file*/
      1 && textarea_hidden_value !== (textarea_hidden_value = !/*file*/
      ctx2[0])) {
        textarea.hidden = textarea_hidden_value;
      }
      if (dirty & /*title*/
      16) {
        set_input_value(
          textarea,
          /*title*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*invalidName*/
      32) {
        toggle_class(
          textarea,
          "MC-sidecar-title-invalid",
          /*invalidName*/
          ctx2[5]
        );
      }
      if (
        /*invalidName*/
        ctx2[5]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*file*/
      1 && div0_hidden_value !== (div0_hidden_value = !/*file*/
      ctx2[0])) {
        div0.hidden = div0_hidden_value;
      }
      if (!current || dirty & /*file*/
      1 && div1_hidden_value !== (div1_hidden_value = !/*file*/
      ctx2[0])) {
        div1.hidden = div1_hidden_value;
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[7](null);
      if (if_block1) if_block1.d();
      ctx[8](null);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let file2 = null;
  let app2 = get_store_value(appStore_default.app);
  let plugin2 = get_store_value(pluginStore_default.plugin);
  const ILLEGAL_FILENAMES = [
    "CON",
    "PRN",
    "AUX",
    "NUL",
    "COM1",
    "COM2",
    "COM3",
    "COM4",
    "COM5",
    "COM6",
    "COM7",
    "COM8",
    "COM9",
    "LPT1",
    "LPT2",
    "LPT3",
    "LPT4",
    "LPT5",
    "LPT6",
    "LPT7",
    "LPT8",
    "LPT9",
    ".",
    ".."
  ];
  const ILLEGAL_FILENAME_CHARACTERS = ["/", "<", ">", ":", '"', "\\", "|", "?", "*", "[", "]", "^", "#"];
  let metadataContainer;
  let editorContainer;
  let titleTextarea;
  let editorView = null;
  let editorObserver;
  let title = "";
  let invalidName = false;
  let renameDebounce = (0, import_obsidian10.debounce)(
    () => {
      renameFile();
    },
    1e3,
    true
  );
  let fileEditDebounce = (0, import_obsidian10.debounce)(
    () => {
      saveFile();
    },
    200,
    true
  );
  let fileContent = "";
  let fileContentLastEdited = 0;
  plugin2.mutationHandler.addEventListener("file-moved", onExternalRename);
  plugin2.mutationHandler.addEventListener("sidecar-edited", onExternalEdit);
  function onExternalRename(e) {
    if (e.detail.oldPath === (file2 === null || file2 === void 0 ? void 0 : file2.file.path)) {
      $$invalidate(0, file2 = e.detail.file);
      $$invalidate(4, title = e.detail.file.file.basename);
    }
  }
  function onExternalEdit(e) {
    if (e.detail === file2) {
      if (editorView) {
        if (fileContentLastEdited + 500 > e.detail.sidecar.file.stat.mtime) return;
        app2.vault.read(e.detail.sidecar.file).then((content) => {
          if (editorView) {
            if (content === editorView.data) return;
            editorObserver.disconnect();
            editorView.set(content, true);
            editorObserver.observe(editorContainer, {
              childList: true,
              subtree: true,
              characterData: true
            });
            fileContent = content;
            fileEditDebounce.cancel();
          }
        });
      }
    }
  }
  function saveFile() {
    if (file2 && editorView) {
      if (fileContent === editorView.data) return;
      fileContent = editorView.data;
      app2.vault.modify(file2.sidecar.file, editorView.data);
    }
  }
  function renameFile() {
    if (!file2) return;
    let trimmed = title.trim();
    let parentPath = file2.file.parent ? file2.file.parent.path : "";
    let newFilePath = (0, import_obsidian9.normalizePath)(parentPath + "/" + trimmed + "." + file2.file.extension);
    if (trimmed === file2.file.basename) {
      $$invalidate(5, invalidName = false);
      return;
    } else if (ILLEGAL_FILENAMES.contains(trimmed) || trimmed.length === 0 || trimmed[trimmed.length - 1] === ".") {
      console.error("[Media Companion]: Illegal filename, file not renamed");
      $$invalidate(5, invalidName = true);
    } else if (app2.vault.getAbstractFileByPathInsensitive(newFilePath)) {
      console.error("[Media Companion]: File already exists, file not renamed");
      $$invalidate(5, invalidName = true);
    } else {
      app2.fileManager.renameFile(file2.file, newFilePath);
      $$invalidate(5, invalidName = false);
    }
  }
  function onTitleInput() {
    renameDebounce();
  }
  function onTitleKeyDown(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      titleTextarea.blur();
    }
    if (ILLEGAL_FILENAME_CHARACTERS.contains(e.key)) {
      e.preventDefault();
    }
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    editorView = app2.embedRegistry.embedByExtension.md({ app: app2, containerEl: editorContainer }, null, "");
    activeStore_default.file.subscribe((newFile) => __awaiter(void 0, void 0, void 0, function* () {
      if (!newFile || !editorView) return;
      renameDebounce.run();
      renameDebounce.cancel();
      fileEditDebounce.run();
      fileEditDebounce.cancel();
      $$invalidate(5, invalidName = false);
      if (editorObserver) {
        editorObserver.disconnect();
      }
      $$invalidate(0, file2 = newFile);
      editorView.set(yield app2.vault.read(newFile.sidecar.file), true);
      $$invalidate(4, title = newFile.file.basename);
      editorObserver = new MutationObserver(() => {
        fileContentLastEdited = Date.now();
        fileEditDebounce();
      });
      editorObserver.observe(editorContainer, {
        childList: true,
        subtree: true,
        characterData: true
      });
    }));
    titleTextarea.addEventListener("input", onTitleInput);
    titleTextarea.addEventListener("keydown", onTitleKeyDown);
    editorView.editable = true;
    if (file2) {
      editorView.set(yield app2.vault.read(file2.sidecar.file), true);
    }
    editorView.inlineTitleEl.style.display = "none";
    editorView.showEditor();
  }));
  onDestroy(() => {
    renameDebounce.run();
    renameDebounce.cancel();
    fileEditDebounce.run();
    fileEditDebounce.cancel();
    if (editorObserver) {
      editorObserver.disconnect();
    }
    plugin2.mutationHandler.removeEventListener("file-moved", onExternalRename);
    plugin2.mutationHandler.removeEventListener("sidecar-edited", onExternalEdit);
    titleTextarea.removeEventListener("input", onTitleInput);
    titleTextarea.removeEventListener("keydown", onTitleKeyDown);
  });
  function textarea_input_handler() {
    title = this.value;
    $$invalidate(4, title);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titleTextarea = $$value;
      $$invalidate(3, titleTextarea);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      metadataContainer = $$value;
      $$invalidate(1, metadataContainer);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorContainer = $$value;
      $$invalidate(2, editorContainer);
    });
  }
  return [
    file2,
    metadataContainer,
    editorContainer,
    titleTextarea,
    title,
    invalidName,
    textarea_input_handler,
    textarea_binding,
    div0_binding,
    div1_binding
  ];
}
var Sidecar2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var Sidecar_default = Sidecar2;

// src/views/sidecar-view.ts
var VIEW_TYPE_SIDECAR = "media-companion-sidecar-view";
var SidecarView = class extends import_obsidian11.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return VIEW_TYPE_SIDECAR;
  }
  getDisplayText() {
    return "Sidecar";
  }
  getIcon() {
    return "image";
  }
  async onOpen() {
    this.component = new Sidecar_default({
      target: this.contentEl,
      props: {}
    });
  }
  async onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// main.ts
var MediaCompanion = class extends import_obsidian12.Plugin {
  async onload() {
    pluginStore_default.plugin.set(this);
    appStore_default.app.set(this.app);
    await this.loadSettings();
    this.cache = new Cache(this.app, this);
    this.mutationHandler = new MutationHandler(this.app, this, this.cache);
    this.registerViews();
    this.app.workspace.onLayoutReady(async () => {
      await this.cache.initialize();
      this.registerEvents();
      this.app.metadataTypeManager.properties[MediaFile.last_updated_tag.toLowerCase()].type = "datetime";
    });
    this.addRibbonIcon("image", "Open gallery", (_) => this.createGallery());
    this.registerCommands();
    this.addSettingTab(new MediaCompanionSettingTab(this.app, this));
  }
  registerEvents() {
    this.mutationHandler.initializeEvents();
    this.registerEvent(this.app.workspace.on("layout-change", async () => {
      const explorers = this.app.workspace.getLeavesOfType("file-explorer");
      for (const explorer of explorers) {
        await this.cache.hideAll(explorer);
      }
    }));
    this.registerEvent(this.app.workspace.on("file-open", async (file2) => {
      if (file2) {
        if (this.settings.extensions.contains(file2.extension.toLowerCase())) {
          const mediaFile = this.cache.getFile(file2.path);
          if (mediaFile) {
            activeStore_default.file.set(mediaFile);
          }
        }
      }
    }));
    activeStore_default.file.subscribe(async (file2) => {
      if (file2) {
        await this.createSidecar();
      }
    });
  }
  registerViews() {
    this.registerView(VIEW_TYPE_GALLERY, (leaf) => new GalleryView(leaf, this));
    this.registerView(VIEW_TYPE_SIDECAR, (leaf) => new SidecarView(leaf));
  }
  registerCommands() {
    this.addCommand({
      id: "open-gallery",
      name: "Open gallery",
      callback: () => this.createGallery()
    });
  }
  async createSidecar(focus = true) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SIDECAR);
    let leaf = null;
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = this.app.workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_SIDECAR, active: true }));
    }
    if (leaf && focus) {
      this.app.workspace.revealLeaf(leaf);
    }
  }
  async createGallery() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_GALLERY);
    let leaf = null;
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = this.app.workspace.getLeaf(true);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_GALLERY, active: true }));
    }
    this.app.workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var MediaCompanionSettingTab = class extends import_obsidian12.PluginSettingTab {
  constructor(app2, plugin2) {
    super(app2, plugin2);
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    const extensionDebounce = (0, import_obsidian12.debounce)(async (value) => {
      this.plugin.settings.extensions = value.split(",").map((ext) => ext.trim()).map((ext) => ext.replace(".", "")).filter((ext) => ext.length > 0).map((ext) => ext.toLowerCase()).filter((ext) => ext !== "md");
      await this.plugin.saveSettings();
      await this.plugin.cache.updateExtensions();
    }, 500, true);
    containerEl.empty();
    new import_obsidian12.Setting(containerEl).setName("Hide sidecar files").setDesc("(Recommended) Hide sidecar files in the file explorer.").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideSidecar).onChange(async (value) => {
      this.plugin.settings.hideSidecar = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian12.Setting(containerEl).setName("Extensions").setDesc("Extensions to be considered as media files, separated by commas.").addTextArea((text2) => text2.setPlaceholder("jpg, png, gif").setValue(this.plugin.settings.extensions.join(", ")).onChange(async (value) => {
      extensionDebounce(value);
    }));
    new import_obsidian12.Setting(containerEl).setName("Sidecar template").setDesc("The template to be used for new sidecar files.").addTextArea((text2) => text2.setPlaceholder("Sidecar template").setValue(this.plugin.settings.sidecarTemplate).onChange(async (value) => {
      this.plugin.settings.sidecarTemplate = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

get-size/get-size.js:
  (*!
   * getSize v2.0.3
   * measure size of elements
   * MIT license
   *)

outlayer/outlayer.js:
  (*!
   * Outlayer v2.1.1
   * the brains and guts of a layout library
   * MIT license
   *)

masonry-layout/masonry.js:
  (*!
   * Masonry v4.2.2
   * Cascading grid layout library
   * https://masonry.desandro.com
   * MIT License
   * by David DeSandro
   *)

imagesloaded/imagesloaded.js:
  (*!
   * imagesLoaded v5.0.0
   * JavaScript is all like "You images are done yet or what?"
   * MIT License
   *)
*/

/* nosourcemap */